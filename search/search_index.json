{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#what-is-rose","title":"What is ROSE?","text":"<p>ROSE = Reduced-Order Scattering Emulator</p> <p><code>rose</code> is a Python package, available on GitHub that enables aspiring graduate students and long-suffering postdocs to emulate nuclear scattering observables with optical potentials, trading negligible amounts of accuracy for orders-of-magnitude gains in speed.</p> <p>Specifically, <code>rose</code> supports user-defined, local, complex potentials. The Koning-Delaroche potential, albeit in simplified form<sup>1</sup>, is hard-coded into <code>rose</code> as <code>KoningDelaroche</code>.</p> <p>Life is full of choices, and many of those choices deal with how you're going to spend your time. Do you really want to spend years of your life, and possibly the lives of your successors, waiting for some computer to finish calculating a cross section? No, you don't. What if you could obtain those results in minutes at the cost of a few significant digits that you weren't going to look at anyway? What if you had a plot to help you make these difficult decisions? Like this one:</p> <p></p> <p>If only the rest of life was so accommodating.</p> <p>For more details about <code>rose</code>, see our organic, artisanal, free-range documentation. Or start with the tutorials.</p> <ol> <li> <p>Take Eq. 2 and ignore the energy dependence of the coefficients.\u00a0\u21a9</p> </li> </ol>"},{"location":"basis/","title":"Bases","text":"<p>The Reduced-Basis Method seeks to reproduce a high-fidelity calculation to a desired accuracy with a set of equations in a lower dimensional space. The main step of the reduction is approximating the high-fidelity wave function by</p> <p>$$ \\phi_{\\rm HF} \\approx \\hat{\\phi} = \\phi_0 + \\sum_i c_i \\tilde{\\phi}_i~. $$</p> <p>These classes calculate and store the basis state $\\phi_0$ and $\\tilde{\\phi}_i$.</p>"},{"location":"basis/#rose.basis.Basis","title":"<code>Basis(solver, theta_train, rho_mesh, n_basis)</code>","text":"<p>Base class / template</p> <p>Builds a reduced basis.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>SchroedingerEquation</code> <p>high-fidelity solver</p> required <code>theta_train</code> <code>ndarray</code> <p>training space</p> required <code>rho_mesh</code> <code>ndarray</code> <p>discrete $s=kr$ mesh points</p> required <code>n_basis</code> <code>int</code> <p>number of states in the expansion</p> required <code>l</code> <code>int</code> <p>orbital angular momentum</p> required <p>Attributes:</p> Name Type Description <code>solver</code> <code>SchroedingerEquation</code> <p>high-fidelity solver</p> <code>theta_train</code> <code>ndarray</code> <p>training space</p> <code>rho_mesh</code> <code>ndarray</code> <p>discrete $s=kr$ mesh points</p> <code>n_basis</code> <code>int</code> <p>number of states in the expansion</p> <code>l</code> <code>int</code> <p>orbital angular momentum</p> Source code in <code>src/rose/basis.py</code> <pre><code>def __init__(\n    self,\n    solver: SchroedingerEquation,\n    theta_train: np.array,\n    rho_mesh: np.array,\n    n_basis: int,\n):\n    r\"\"\"Builds a reduced basis.\n\n    Parameters:\n        solver (SchroedingerEquation): high-fidelity solver\n        theta_train (ndarray): training space\n        rho_mesh (ndarray): discrete $s=kr$ mesh points\n        n_basis (int): number of states in the expansion\n        l (int): orbital angular momentum\n\n    Attributes:\n        solver (SchroedingerEquation): high-fidelity solver\n        theta_train (ndarray): training space\n        rho_mesh (ndarray): discrete $s=kr$ mesh points\n        n_basis (int): number of states in the expansion\n        l (int): orbital angular momentum\n\n    \"\"\"\n    self.solver = solver\n    self.l = solver.interaction.ell\n    self.theta_train = theta_train\n    self.rho_mesh = rho_mesh\n    self.n_basis = n_basis\n</code></pre>"},{"location":"basis/#rose.basis.Basis.load","title":"<code>load(filename)</code>  <code>classmethod</code>","text":"<p>Loads a previously saved Basis.</p> Source code in <code>src/rose/basis.py</code> <pre><code>@classmethod\ndef load(cls, filename):\n    r\"\"\"Loads a previously saved Basis.\"\"\"\n    with open(filename, \"rb\") as f:\n        basis = pickle.load(f)\n    return basis\n</code></pre>"},{"location":"basis/#rose.basis.Basis.phi_exact","title":"<code>phi_exact(theta)</code>","text":"<p>Exact wave function.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>ndarray</code> <p>parameters</p> required <code>l (int) </code> <p>partial wave</p> required <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>wave function</p> Source code in <code>src/rose/basis.py</code> <pre><code>def phi_exact(self, theta: np.array):\n    r\"\"\"Exact wave function.\n\n    Parameters:\n        theta (ndarray): parameters\n        l (int) : partial wave\n\n    Returns:\n        phi (ndarray): wave function\n\n    \"\"\"\n    return self.solver.phi(theta, self.rho_mesh)\n</code></pre>"},{"location":"basis/#rose.basis.Basis.phi_hat","title":"<code>phi_hat(coefficients)</code>","text":"<p>Emulated wave function.</p> <p>Every basis should know how to reconstruct hat{phi} from a set of coefficients. However, this is going to be different for each basis, so we will leave it up to the subclasses to implement this.</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>ndarray</code> <p>expansion coefficients</p> required <p>Returns:</p> Name Type Description <code>phi_hat</code> <code>ndarray</code> <p>approximate wave function</p> Source code in <code>src/rose/basis.py</code> <pre><code>def phi_hat(self, coefficients):\n    r\"\"\"Emulated wave function.\n\n    Every basis should know how to reconstruct hat{phi} from a set of\n    coefficients. However, this is going to be different for each basis, so\n    we will leave it up to the subclasses to implement this.\n\n    Parameters:\n        coefficients (ndarray): expansion coefficients\n\n    Returns:\n        phi_hat (ndarray): approximate wave function\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"basis/#rose.basis.Basis.save","title":"<code>save(filename)</code>","text":"<p>Saves a basis to file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>string</code> <p>name of file</p> required Source code in <code>src/rose/basis.py</code> <pre><code>def save(self, filename):\n    \"\"\"Saves a basis to file.\n\n    Parameters:\n        filename (string): name of file\n\n    \"\"\"\n    with open(filename, \"wb\") as f:\n        pickle.dump(self, f)\n</code></pre>"},{"location":"basis/#rose.basis.CustomBasis","title":"<code>CustomBasis(solutions, phi_0, rho_mesh, n_basis, expl_var_ratio_cutoff=None, solver=None, subtract_phi0=True, use_svd=None, center=None, scale=None)</code>","text":"<p>               Bases: <code>Basis</code></p> <p>Builds a custom basis. Allows the user to supply their own.</p> <p>$$ \\phi_{\\rm HF} \\approx \\hat{\\phi} = \\phi_0 + \\sum_i c_i \\tilde{\\phi}_i~. $$</p> <p>Parameters:</p> Name Type Description Default <code>solutions</code> <code>ndarray</code> <p>HF solutions</p> required <code>phi_0</code> <code>ndarray</code> <p>free solution (no interaction)</p> required <code>rho_mesh</code> <code>ndarray</code> <p>discrete $s=kr$ mesh points</p> required <code>n_basis</code> <code>int</code> <p>min number of states in the expansion</p> required <code>expl_var_ratio_cutoff (float) </code> <p>the cutoff in sv2/sum(sv2), sv being the singular values, at which the number of kept bases is chosen</p> required <code>use_svd</code> <code>bool</code> <p>Use principal components for $\\tilde{\\phi}$?</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>solver</code> <code>SchroedingerEquation</code> <p>not specified or assumed at construction</p> <code>theta_train</code> <code>ndarray</code> <p>not specified or assumed at construction</p> <code>rho_mesh</code> <code>ndarray</code> <p>discrete $s=kr$ mesh points</p> <code>n_basis</code> <code>int</code> <p>number of states in the expansion</p> <code>phi_0</code> <code>ndarray</code> <p>free solution (no interaction)</p> <code>solutions</code> <code>ndarray</code> <p>HF solutions provided by the user</p> <code>pillars</code> <code>ndarray</code> <p>$\\tilde{\\phi}_i$</p> <code>singular_values</code> <code>ndarray</code> <p>singular values from SVD</p> <code>vectors</code> <code>ndarray</code> <p>copy of <code>pillars</code></p> <code>phi_0_interp</code> <code>interp1d</code> <p>interpolating function for $\\phi_0$</p> <code>vectors_interp</code> <code>interp1d</code> <p>interpolating functions for vectors (basis states)</p> Source code in <code>src/rose/basis.py</code> <pre><code>def __init__(\n    self,\n    solutions: np.array,  # HF solutions, columns\n    phi_0: np.array,  # \"offset\", generates inhomogeneous term\n    rho_mesh: np.array,  # rho mesh; MUST BE EQUALLY SPACED POINTS!!!\n    n_basis: int,\n    expl_var_ratio_cutoff: float = None,\n    solver: SchroedingerEquation = None,\n    subtract_phi0=True,\n    use_svd: bool = None,\n    center: bool = None,\n    scale: bool = None,\n):\n    r\"\"\"Builds a custom basis. Allows the user to supply their own.\n\n    $$\n    \\phi_{\\rm HF} \\approx \\hat{\\phi} = \\phi_0 + \\sum_i c_i \\tilde{\\phi}_i~.\n    $$\n\n    Parameters:\n        solutions (ndarray): HF solutions\n        phi_0 (ndarray): free solution (no interaction)\n        rho_mesh (ndarray): discrete $s=kr$ mesh points\n        n_basis (int): min number of states in the expansion\n        expl_var_ratio_cutoff (float) : the cutoff in sv**2/sum(sv**2), sv\n            being the singular values, at which the number of kept bases is chosen\n        use_svd (bool): Use principal components for $\\tilde{\\phi}$?\n\n    Attributes:\n        solver (SchroedingerEquation): not specified or assumed at construction\n        theta_train (ndarray): not specified or assumed at construction\n        rho_mesh (ndarray): discrete $s=kr$ mesh points\n        n_basis (int): number of states in the expansion\n        phi_0 (ndarray): free solution (no interaction)\n        solutions (ndarray): HF solutions provided by the user\n        pillars (ndarray): $\\tilde{\\phi}_i$\n        singular_values (ndarray): singular values from SVD\n        vectors (ndarray): copy of `pillars`\n        phi_0_interp (interp1d): interpolating function for $\\phi_0$\n        vectors_interp (interp1d): interpolating functions for vectors (basis states)\n\n    \"\"\"\n\n    super().__init__(solver, None, rho_mesh, n_basis)\n\n    self.rho_mesh = rho_mesh\n    self.n_basis = n_basis\n    self.phi_0 = phi_0\n\n    self.pillars, self.singular_values, self.phi_0 = pre_process_solutions(\n        solutions, self.phi_0, self.rho_mesh, center, scale, use_svd, subtract_phi0\n    )\n\n    # keeping at min n_basis PC's, find cutoff\n    if expl_var_ratio_cutoff is not None:\n        expl_var = self.singular_values**2 / np.sum(self.singular_values**2)\n        n_basis_svs = np.sum(expl_var &gt; expl_var_ratio_cutoff)\n        self.n_basis = max(n_basis_svs, self.n_basis)\n    else:\n        self.n_basis = n_basis\n\n    self.vectors = self.pillars[:, : self.n_basis]\n</code></pre>"},{"location":"basis/#rose.basis.CustomBasis.percent_explained_variance","title":"<code>percent_explained_variance()</code>","text":"<p>Returns:</p> Type Description <p>(float) : percent of variance explained in the training set by the first n_basis principal</p> <p>components</p> Source code in <code>src/rose/basis.py</code> <pre><code>def percent_explained_variance(self):\n    r\"\"\"\n    Returns:\n        (float) : percent of variance explained in the training set by the first n_basis principal\n        components\n    \"\"\"\n    if self.singular_values is None:\n        return 100\n    else:\n        return np.array(\n            [\n                100\n                * np.sum(self.singular_values[:i] ** 2)\n                / np.sum(self.singular_values**2)\n            ]\n            for i in range(self.nbasis)\n        )\n</code></pre>"},{"location":"basis/#rose.basis.CustomBasis.phi_hat","title":"<code>phi_hat(coefficients)</code>","text":"<p>Emulated wave function.</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>ndarray</code> <p>expansion coefficients</p> required <p>Returns:</p> Name Type Description <code>phi_hat</code> <code>ndarray</code> <p>approximate wave function</p> Source code in <code>src/rose/basis.py</code> <pre><code>def phi_hat(self, coefficients):\n    r\"\"\"Emulated wave function.\n\n    Parameters:\n        coefficients (ndarray): expansion coefficients\n\n    Returns:\n        phi_hat (ndarray): approximate wave function\n\n    \"\"\"\n    return self.phi_0 + np.sum(coefficients * self.vectors, axis=1)\n</code></pre>"},{"location":"basis/#rose.basis.CustomBasis.project","title":"<code>project(x)</code>","text":"<p>Return projection of x onto vectors</p> Source code in <code>src/rose/basis.py</code> <pre><code>def project(self, x):\n    r\"\"\"\n    Return projection of x onto vectors\n    \"\"\"\n    x -= self.phi_0\n    x /= np.trapz(np.absolute(x), self.rho_mesh)\n    return [\n        np.trapz(self.vectors[:, i].conj() * x, self.rho_mesh)\n        for i in range(self.n_basis)\n    ]\n</code></pre>"},{"location":"basis/#rose.basis.RelativeBasis","title":"<code>RelativeBasis(solver, theta_train, rho_mesh, n_basis, expl_var_ratio_cutoff=None, phi_0_energy=None, use_svd=True, center=None, scale=None)</code>","text":"<p>               Bases: <code>Basis</code></p> <p>Builds a \"relative\" reduced basis. This is the default choice.</p> <p>$$ \\phi_{\\rm HF} \\approx \\hat{\\phi} = \\phi_0 + \\sum_i c_i \\tilde{\\phi}_i~. $$</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>SchroedingerEquation</code> <p>high-fidelity solver</p> required <code>theta_train</code> <code>ndarray</code> <p>training space</p> required <code>rho_mesh</code> <code>ndarray</code> <p>discrete $s=kr$ mesh points</p> required <code>n_basis</code> <code>int</code> <p>number of states in the expansion</p> required <code>l</code> <code>int</code> <p>orbital angular momentum</p> required <code>use_svd</code> <code>bool</code> <p>Use principal components for $\\tilde{\\phi}$?</p> <code>True</code> <code>phi_0_energy</code> <code>float</code> <p>energy at which $\\phi_0$ is calculated</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>solver</code> <code>SchroedingerEquation</code> <p>high-fidelity solver</p> <code>theta_train</code> <code>ndarray</code> <p>training space</p> <code>rho_mesh</code> <code>ndarray</code> <p>discrete $s=kr$ mesh points</p> <code>n_basis</code> <code>int</code> <p>number of states in the expansion</p> <code>l</code> <code>int</code> <p>orbital angular momentum</p> <code>phi_0</code> <code>ndarray</code> <p>free solution (no interaction)</p> <code>pillars</code> <code>ndarray</code> <p>$\\tilde{\\phi}_i$</p> <code>singular_values</code> <code>ndarray</code> <p>singular values from SVD</p> <code>vectors</code> <code>ndarray</code> <p>copy of <code>pillars</code></p> Source code in <code>src/rose/basis.py</code> <pre><code>def __init__(\n    self,\n    solver: SchroedingerEquation,\n    theta_train: np.array,\n    rho_mesh: np.array,\n    n_basis: int,\n    expl_var_ratio_cutoff: float = None,\n    phi_0_energy: float = None,\n    use_svd: bool = True,\n    center: bool = None,\n    scale: bool = None,\n):\n    r\"\"\"Builds a \"relative\" reduced basis. This is the default choice.\n\n    $$\n    \\phi_{\\rm HF} \\approx \\hat{\\phi} = \\phi_0 + \\sum_i c_i \\tilde{\\phi}_i~.\n    $$\n\n    Parameters:\n        solver (SchroedingerEquation): high-fidelity solver\n        theta_train (ndarray): training space\n        rho_mesh (ndarray): discrete $s=kr$ mesh points\n        n_basis (int): number of states in the expansion\n        l (int): orbital angular momentum\n        use_svd (bool): Use principal components for $\\tilde{\\phi}$?\n        phi_0_energy (float): energy at which $\\phi_0$ is calculated\n\n    Attributes:\n        solver (SchroedingerEquation): high-fidelity solver\n        theta_train (ndarray): training space\n        rho_mesh (ndarray): discrete $s=kr$ mesh points\n        n_basis (int): number of states in the expansion\n        l (int): orbital angular momentum\n        phi_0 (ndarray): free solution (no interaction)\n        pillars (ndarray): $\\tilde{\\phi}_i$\n        singular_values (ndarray): singular values from SVD\n        vectors (ndarray): copy of `pillars`\n\n    \"\"\"\n\n    super().__init__(\n        solver,\n        theta_train,\n        rho_mesh,\n        n_basis,\n    )\n\n    if phi_0_energy is not None:\n        k = np.sqrt(2 * self.solver.interaction.mu * phi_0_energy / HBARC**2)\n        eta = self.solver.interaction.k_c / k\n    else:\n        if isinstance(self.solver.interaction, EnergizedInteractionEIM):\n            # k_mean = np.sqrt(2*self.solver.interaction.mu*np.mean(theta_train[:, 0])/HBARC**2)\n            # eta = self.solver.interaction.k_c / k_mean\n            # Does not support Coulomb (yet).\n            eta = 0.0\n        else:\n            # If the phi_0 energy is not specified, we're only going to work\n            # with non-Coulombic systems (for now).\n            eta = 0.0\n\n    # Returns Bessel functions when eta = 0.\n    self.phi_0 = np.array(\n        [coulombf(self.l, eta, rho) for rho in self.rho_mesh], dtype=np.complex128\n    )\n    self.solutions = np.array([self.phi_exact(theta) for theta in theta_train]).T\n\n    self.pillars, self.singular_values, self.phi_0 = pre_process_solutions(\n        self.solutions, self.phi_0, self.rho_mesh, center, scale, use_svd\n    )\n\n    # keeping at min n_basis PC's, find cutoff\n    if expl_var_ratio_cutoff is not None:\n        expl_var = self.singular_values**2 / np.sum(self.singular_values**2)\n        n_basis_svs = np.sum(expl_var &gt; expl_var_ratio_cutoff)\n        self.n_basis = max(n_basis_svs, self.n_basis)\n    else:\n        self.n_basis = n_basis\n\n    self.vectors = self.pillars[:, : self.n_basis].copy()\n</code></pre>"},{"location":"basis/#rose.basis.RelativeBasis.percent_explained_variance","title":"<code>percent_explained_variance()</code>","text":"<p>Returns:</p> Type Description <p>(float) : percent of variance explained in the training set by the first n_basis principal</p> <p>components</p> Source code in <code>src/rose/basis.py</code> <pre><code>def percent_explained_variance(self):\n    r\"\"\"\n    Returns:\n        (float) : percent of variance explained in the training set by the first n_basis principal\n        components\n    \"\"\"\n    if self.singular_values is None:\n        return 100\n    else:\n        return np.array(\n            [\n                100\n                * np.sum(self.singular_values[:i] ** 2)\n                / np.sum(self.singular_values**2)\n            ]\n            for i in range(self.nbasis)\n        )\n</code></pre>"},{"location":"basis/#rose.basis.RelativeBasis.phi_hat","title":"<code>phi_hat(coefficients)</code>","text":"<p>Emulated wave function.</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>ndarray</code> <p>expansion coefficients</p> required <p>Returns:</p> Name Type Description <code>phi_hat</code> <code>ndarray</code> <p>approximate wave function</p> Source code in <code>src/rose/basis.py</code> <pre><code>def phi_hat(self, coefficients):\n    r\"\"\"Emulated wave function.\n\n    Parameters:\n        coefficients (ndarray): expansion coefficients\n\n    Returns:\n        phi_hat (ndarray): approximate wave function\n\n    \"\"\"\n    return self.phi_0 + np.sum(coefficients * self.vectors, axis=1)\n</code></pre>"},{"location":"basis/#rose.basis.RelativeBasis.project","title":"<code>project(x)</code>","text":"<p>Return projection of x onto vectors</p> Source code in <code>src/rose/basis.py</code> <pre><code>def project(self, x):\n    r\"\"\"\n    Return projection of x onto vectors\n    \"\"\"\n    x -= self.phi_0\n    x /= np.trapz(np.absolute(x), self.rho_mesh)\n    return [\n        np.trapz(self.vectors[:, i].conj() * x, self.rho_mesh)\n        for i in range(self.n_basis)\n    ]\n</code></pre>"},{"location":"contact/","title":"Contact Information","text":"<p>Do you have a question? Did you find a bug? <code>rose</code> is hosted on GitHub, and we rely heavily on Issues and Pull Requests. Feel free to contribute whatever feedback you're willing to share.</p>"},{"location":"hifi_solver/","title":"High-Fidelity Solver","text":"<p><code>SchroedingerEquation</code> is a high-fidelity (HF), Schr\u00f6dinger-equation solver for local, complex interactions.</p> <p>By default, <code>rose</code> will provide HF solution using <code>scipy.integrate.solve_ivp</code>. For details about providing your own solutions, see Basis documentation.</p>"},{"location":"hifi_solver/#rose.schroedinger.SchroedingerEquation","title":"<code>SchroedingerEquation(interaction, rk_tols=[1e-09, 1e-09], s_0=None, domain=None)</code>","text":"<p>Solver for the single-channel, reduced, radial Schr\u00f6dinger equation using scipy.integrate https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html</p> <p>All other solvers for the single-channel, reduced, radial Schr\u00f6dinger equation inherit from this class</p> <p>Solves the Shr\u00f6dinger equation for local, complex potentials.</p> <p>Parameters:</p> Name Type Description Default <code>interaction</code> <code>Interaction</code> <p>See Interaction documentation.</p> required <code>rk_tols</code> <code>list</code> <p>2-element list of numbers specifying tolerances for the Runge-Kutta solver: the relative tolerance and the  absolute tolerance</p> <code>[1e-09, 1e-09]</code> <code>s_0 (float) </code> required <code>domain (ndarray) </code> required <p>Returns:</p> Name Type Description <code>solver</code> <code>SchroedingerEquation</code> <p>instance of <code>SchroedingerEquation</code></p> Source code in <code>src/rose/schroedinger.py</code> <pre><code>def __init__(\n    self,\n    interaction: Interaction,\n    rk_tols: list = [1e-9, 1e-9],\n    s_0=None,\n    domain=None,\n):\n    r\"\"\"Solves the Shr\u00f6dinger equation for local, complex potentials.\n\n    Parameters:\n        interaction (Interaction): See [Interaction documentation](interaction.md).\n        rk_tols (list): 2-element list of numbers specifying tolerances for the\n            Runge-Kutta solver: the relative tolerance and the  absolute tolerance\n        s_0 (float) :\n        domain (ndarray) :\n\n    Returns:\n        solver (SchroedingerEquation): instance of `SchroedingerEquation`\n\n    \"\"\"\n    if domain is None:\n        domain = np.array([self.DEFAULT_S_MIN, self.DEFAULT_S_MAX])\n\n    if s_0 is None:\n        s_0 = domain[1] - np.pi\n        assert s_0 &gt; 0\n\n    assert domain[1] &gt; s_0\n\n    self.s_0 = s_0\n    self.domain = domain.copy()\n    self.interaction = interaction\n    self.rk_tols = rk_tols\n\n    if self.interaction is not None:\n        if self.interaction.k_c == 0:\n            self.eta = 0\n        else:\n            # There is Coulomb, but we haven't (yet) worked out how to emulate\n            # across energies, so we can precompute H+ and H- stuff.\n            self.eta = self.interaction.eta(None)\n\n        self.Hm = H_minus(self.s_0, self.interaction.ell, self.eta)\n        self.Hp = H_plus(self.s_0, self.interaction.ell, self.eta)\n        self.Hmp = H_minus_prime(self.s_0, self.interaction.ell, self.eta)\n        self.Hpp = H_plus_prime(self.s_0, self.interaction.ell, self.eta)\n\n        self.domain[0], self.init_cond = self.initial_conditions(\n            self.eta,\n            self.PHI_THRESHOLD,\n            self.interaction.ell,\n            self.domain[0],\n        )\n\n        assert self.domain[0] &lt; self.s_0\n</code></pre>"},{"location":"hifi_solver/#rose.schroedinger.SchroedingerEquation.delta","title":"<code>delta(alpha, **kwargs)</code>","text":"<p>Calculates the $\\ell$-th partial wave phase shift</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter vector</p> required <p>Returns:</p> Name Type Description <code>delta</code> <code>float</code> <p>phase shift extracted from the reduced, radial wave function</p> Source code in <code>src/rose/schroedinger.py</code> <pre><code>def delta(\n    self,\n    alpha: np.array,\n    **kwargs,\n):\n    r\"\"\"Calculates the $\\ell$-th partial wave phase shift\n\n    Parameters:\n        alpha (ndarray): parameter vector\n\n    Returns:\n        delta (float): phase shift extracted from the reduced, radial\n            wave function\n\n    \"\"\"\n    sl = self.smatrix(alpha, **kwargs)\n\n    return np.log(sl) / 2j\n</code></pre>"},{"location":"hifi_solver/#rose.schroedinger.SchroedingerEquation.initial_conditions","title":"<code>initial_conditions(eta, phi_threshold, l, rho_0=None)</code>","text":"<p>Returns:</p> Type Description <p>initial_conditions (tuple) : initial conditions [phi, phi'] at rho_0</p> <p>Parameters:</p> Name Type Description Default <code>eta</code> <code>float</code> <p>sommerfield param</p> required <code>phi_threshold</code> <code>float</code> <p>minimum $\\phi$ value; The wave function is considered zero below this value.</p> required <code>rho_0</code> <code>float</code> <p>starting point for the solver</p> <code>None</code> Source code in <code>src/rose/schroedinger.py</code> <pre><code>def initial_conditions(self, eta: float, phi_threshold: float, l: int, rho_0=None):\n    r\"\"\"\n    Returns:\n        initial_conditions (tuple) : initial conditions [phi, phi'] at rho_0\n\n    Parameters:\n        eta (float): sommerfield param\n        phi_threshold (float): minimum $\\phi$ value; The wave function is\n            considered zero below this value.\n        rho_0 (float): starting point for the solver\n    \"\"\"\n\n    C_l = Gamow_factor(l, eta)\n    min_rho_0 = (phi_threshold / C_l) ** (1 / (l + 1))\n\n    if min_rho_0 &gt; rho_0:\n        rho_0 = min_rho_0\n\n    phi_0 = C_l * rho_0 ** (l + 1)\n    phi_prime_0 = C_l * (l + 1) * rho_0**l\n\n    if self.interaction.is_complex:\n        initial_conditions = np.array([phi_0 * (1 + 0j), phi_prime_0 * (1 + 0j)])\n    else:\n        initial_conditions = np.array([phi_0, phi_prime_0])\n\n    return rho_0, initial_conditions\n</code></pre>"},{"location":"hifi_solver/#rose.schroedinger.SchroedingerEquation.phi","title":"<code>phi(alpha, s_mesh, **kwargs)</code>","text":"<p>Computes the reduced, radial wave function $\\phi$ (or $u$) on <code>s_mesh</code> using the Runge-Kutta method</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter vector</p> required <code>s_mesh</code> <code>ndarray</code> <p>values of $s$ at which $\\phi$ is calculated</p> required <code>kwargs (dict) </code> <p>passed to scipy.integrate.solve_ivp</p> required <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>reduced, radial wave function</p> Source code in <code>src/rose/schroedinger.py</code> <pre><code>def phi(\n    self,\n    alpha: np.array,\n    s_mesh: np.array,\n    **kwargs,\n):\n    r\"\"\"Computes the reduced, radial wave function $\\phi$ (or $u$) on `s_mesh` using the\n    Runge-Kutta method\n\n    Parameters:\n        alpha (ndarray): parameter vector\n        s_mesh (ndarray): values of $s$ at which $\\phi$ is calculated\n        kwargs (dict) : passed to scipy.integrate.solve_ivp\n\n    Returns:\n        phi (ndarray): reduced, radial wave function\n\n    \"\"\"\n    solution = np.zeros_like(s_mesh, dtype=np.complex128)\n    mask = np.logical_and(s_mesh &gt;= self.domain[0], s_mesh &lt;= self.domain[1])\n    phi = self.solve_se(alpha, **kwargs)\n    solution[mask] = phi(s_mesh)[0][mask]\n    return solution\n</code></pre>"},{"location":"hifi_solver/#rose.schroedinger.SchroedingerEquation.rmatrix","title":"<code>rmatrix(alpha, **kwargs)</code>","text":"<p>Calculates the $\\ell$-th partial wave R-matrix element at the specified energy.     using the Runge-Kutta method for integrating the Radial SE. kwargs are passed to     solve_se.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter vector</p> required <code>kwargs (dict) </code> <p>passed to scipy.integrate.solve_ivp</p> required <p>Returns:</p> Type Description <p>rl (float)  : r-matrix element, or logarithmic derivative of wavefunction at the channel radius; s_0</p> Source code in <code>src/rose/schroedinger.py</code> <pre><code>def rmatrix(\n    self,\n    alpha: np.array,\n    **kwargs,\n):\n    r\"\"\"Calculates the $\\ell$-th partial wave R-matrix element at the specified energy.\n        using the Runge-Kutta method for integrating the Radial SE. kwargs are passed to\n        solve_se.\n\n    Parameters:\n        alpha (ndarray): parameter vector\n        kwargs (dict) : passed to scipy.integrate.solve_ivp\n\n    Returns:\n        rl (float)  : r-matrix element, or logarithmic derivative of wavefunction at the channel\n            radius; s_0\n\n    \"\"\"\n    solution = self.solve_se(alpha, **kwargs)\n    u = solution(self.s_0)\n    rl = 1 / self.s_0 * (u[0] / u[1])\n    return rl\n</code></pre>"},{"location":"hifi_solver/#rose.schroedinger.SchroedingerEquation.solve_se","title":"<code>solve_se(alpha, **kwargs)</code>","text":"<p>Solves the reduced, radial Schr\u00f6dinger equation using the builtin in Runge-Kutta     solver in scipy.integrate.solve_ivp</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter vector</p> required <code>kwargs (dict) </code> <p>passed to scipy.integrate.solve_ivp</p> required <p>Returns:</p> Type Description <p>sol  (scipy.integrate.OdeSolution) : the radial wavefunction</p> <p>and its first derivative; see https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.OdeSolution.html#scipy.integrate.OdeSolution</p> Source code in <code>src/rose/schroedinger.py</code> <pre><code>def solve_se(\n    self,\n    alpha: np.array,\n    **kwargs,\n):\n    r\"\"\"Solves the reduced, radial Schr\u00f6dinger equation using the builtin in Runge-Kutta\n        solver in scipy.integrate.solve_ivp\n\n    Parameters:\n        alpha (ndarray): parameter vector\n        kwargs (dict) : passed to scipy.integrate.solve_ivp\n\n    Returns:\n        sol  (scipy.integrate.OdeSolution) : the radial wavefunction\n        and its first derivative; see https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.OdeSolution.html#scipy.integrate.OdeSolution\n    \"\"\"\n\n    args = self.interaction.bundle_gcoeff_args(alpha)\n    sol = solve_ivp(\n        lambda s, phi: np.array(\n            [\n                phi[1],\n                -1 * g_coeff(s, *args) * phi[0],\n            ]\n        ),\n        self.domain,\n        self.init_cond,\n        rtol=self.rk_tols[0],\n        atol=self.rk_tols[1],\n        dense_output=True,\n        **kwargs,\n    )\n\n    return sol.sol\n</code></pre>"},{"location":"interaction/","title":"Interactions","text":"<p>In general, <code>rose</code> supports local, complex interactions. While we expect that most users will take advantage of the hard-coded Koning-Delaroche potential, we have always written <code>rose</code> with the expectation that many users will want to define their own interactions. The classes below make that process more convenient.</p> <p>The most basic interaction is affectionately and creatively referred to as: <code>Interaction</code>. It supports fixed-energy interactions whose parameter dependece is affine. The corresponding class, <code>InteractionSpace</code>, generates a list of $\\ell$-specific <code>Interactions</code>.</p> <p>For fixed-energy interactions for which the parameter dependence is non-affine, we have <code>InteractionEIM</code> and <code>InteractionEIMSpace</code>. The classes leverage the Empirical Interpolation Method (EIM) to render that which was non-affine affine.</p> <p>For non-affine, energy-dependent interactions, we have <code>EnergizedInteractionEIM</code> and <code>EnergizedInteractionEIMSpace</code>. <code>rose</code> works with the energy-scaled Schr\u00f6dinger equation, so one might think that the scaled interaction is linear in $1/E$. However, because we also work in the dimensionless space, $s\\equiv kr$, the dependence is more complex. We again rely on EIM to capture these complexities. (You don't need to know all of that. We just wanted you to impress you.)</p>"},{"location":"interaction/#affine-fixed-energy-interactions","title":"Affine, Fixed-Energy Interactions","text":"<p>Wraps the user-defined interaction into a class that stores several relevant parameters of the problem.</p>"},{"location":"interaction/#rose.interaction.Interaction","title":"<code>Interaction(ell=0, spin_orbit_term=None, coordinate_space_potential=None, n_theta=None, mu=None, energy=None, k=None, Z_1=0, Z_2=0, R_C=0.0, is_complex=False)</code>","text":"<p>Defines a local, (possibly) complex, affine, fixed-energy interaction.</p> <p>Creates a local, (possibly) complex, affine, fixed-energy interaction.</p> <p>Parameters:</p> Name Type Description Default <code>coordinate_space_potential</code> <code>Callable[[float, ndarray], float]</code> <p>V(r, theta)</p> <code>None</code> <code>n_theta</code> <code>int</code> <p>number of parameters</p> <code>None</code> <code>mu</code> <code>float</code> <p>reduced mass</p> <code>None</code> <code>energy</code> <code>float</code> <p>center-of-mass, scattering energy</p> <code>None</code> <code>ell</code> <code>int</code> <p>angular momentum</p> <code>0</code> <code>Z_1</code> <code>int</code> <p>charge of particle 1</p> <code>0</code> <code>Z_2</code> <code>int</code> <p>charge of particle 2</p> <code>0</code> <code>R_C</code> <code>float</code> <p>Coulomb \"cutoff\" radius</p> <code>0.0</code> <code>is_complex</code> <code>bool</code> <p>Is the interaction complex?</p> <code>False</code> <code>spin_orbit_term</code> <code>SpinOrbitTerm</code> <p>See Spin-Orbit section.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>instance</code> <code>Interaction</code> <p>instance of <code>Interaction</code></p> <p>Attributes:</p> Name Type Description <code>v_r</code> <code>Callable[[float, ndarray], float]</code> <p>coordinate-space potential; $V(r, \\alpha)$</p> <code>n_theta</code> <code>int</code> <p>number of parameters</p> <code>mu</code> <code>float</code> <p>reduced mass</p> <code>ell</code> <code>int</code> <p>angular momentum</p> <code>k_c</code> <code>float</code> <p>Coulomb momentum; $k\\eta$</p> <code>is_complex</code> <code>bool</code> <p>Is this a complex potential?</p> <code>spin_orbit_term</code> <code>SpinOrbitTerm</code> <p>See Spin-Orbit section</p> Source code in <code>src/rose/interaction.py</code> <pre><code>def __init__(\n    self,\n    ell: int = 0,\n    spin_orbit_term: SpinOrbitTerm = None,\n    coordinate_space_potential: Callable[[float, np.array], float] = None,\n    n_theta: int = None,\n    mu: float = None,\n    energy: float = None,\n    k: float = None,\n    Z_1: int = 0,\n    Z_2: int = 0,\n    R_C: float = 0.0,\n    is_complex: bool = False,\n):\n    r\"\"\"Creates a local, (possibly) complex, affine, fixed-energy interaction.\n\n    Parameters:\n        coordinate_space_potential (Callable[[float,ndarray],float]): V(r, theta)\n        n_theta (int): number of parameters\n        mu (float): reduced mass\n        energy (float): center-of-mass, scattering energy\n        ell (int): angular momentum\n        Z_1 (int): charge of particle 1\n        Z_2 (int): charge of particle 2\n        R_C (float): Coulomb \"cutoff\" radius\n        is_complex (bool): Is the interaction complex?\n        spin_orbit_term (SpinOrbitTerm): See [Spin-Orbit section](#spin-orbit).\n\n    Returns:\n        instance (Interaction): instance of `Interaction`\n\n    Attributes:\n        v_r (Callable[[float,ndarray],float]): coordinate-space potential; $V(r, \\alpha)$\n        n_theta (int): number of parameters\n        mu (float): reduced mass\n        ell (int): angular momentum\n        k_c (float): Coulomb momentum; $k\\eta$\n        is_complex (bool): Is this a complex potential?\n        spin_orbit_term (SpinOrbitTerm): See [Spin-Orbit section](#spin-orbit)\n\n    \"\"\"\n    assert coordinate_space_potential is not None\n    assert n_theta &gt; 0\n\n    assert ell &gt;= 0\n    self.Z_1 = Z_1\n    self.Z_2 = Z_2\n    self.v_r = coordinate_space_potential\n    self.n_theta = n_theta\n    self.ell = ell\n    self.is_complex = is_complex\n    self.spin_orbit_term = spin_orbit_term\n\n    if spin_orbit_term is None:\n        self.spin_orbit_term = SpinOrbitTerm()\n        self.include_spin_orbit = False\n    else:\n        self.include_spin_orbit = True\n\n    self.k = k\n    self.mu = mu\n    self.energy = energy\n    self.R_C = R_C\n    if R_C &lt;= 0.0:\n        R_C = 1e-9\n    self.sommerfeld = 0.0\n\n    if mu is not None:\n        self.k_c = ALPHA * Z_1 * Z_2 * self.mu / HBARC\n    else:\n        self.k_c = 0  # TODO mu/energy emulation does not support Coulomb\n        assert self.Z_1 * self.Z_1 == 0\n\n    if energy is not None:\n        # If the energy is specified (not None as it is when subclass\n        # EnergizedInteraction instantiates), set up associated attributes.\n        if mu is not None and k is None:\n            self.k = np.sqrt(2 * self.mu * self.energy) / HBARC\n        self.sommerfeld = self.k_c / self.k\n</code></pre>"},{"location":"interaction/#rose.interaction.Interaction.E","title":"<code>E(alpha)</code>","text":"<p>Energy. Implemented as a function to support energy emulation (where the energy could be a part of the parameter vector, <code>alpha</code>).</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter vector</p> required <p>Returns:</p> Name Type Description <code>Energy</code> <code>float</code> <p>in [MeV]</p> Source code in <code>src/rose/interaction.py</code> <pre><code>def E(self, alpha: np.array):\n    r\"\"\"Energy. Implemented as a function to support energy\n    emulation (where the energy could be a part of the parameter vector,\n    `alpha`).\n\n    Parameters:\n        alpha (ndarray): parameter vector\n\n    Returns:\n        Energy (float): in [MeV]\n    \"\"\"\n    return self.energy\n</code></pre>"},{"location":"interaction/#rose.interaction.Interaction.basis_functions","title":"<code>basis_functions(rho_mesh)</code>","text":"<p>In general, we approximate the potential as</p> <p>$\\hat{U} = \\sum_{j} \\beta_j(\\alpha) u_j$</p> <p>For affine interactions (like those defined in this class) the basis functions (or \"pillars), $u_j$, are just the \"naked\" parts of the potential. As seen below, it is assumed that the $\\beta_j(\\alpha)$ coefficients are just the affine parameters, $\\alpha$, themselves.</p> <p>Parameters:</p> Name Type Description Default <code>rho_mesh</code> <code>ndarray</code> <p>discrete $\\rho$ values at which the potential is going to be evaluated</p> required <p>Returns:</p> Name Type Description <code>value</code> <code>ndarray</code> <p>values of the scaled potential at provided $\\rho$ points</p> Source code in <code>src/rose/interaction.py</code> <pre><code>def basis_functions(self, rho_mesh: np.array):\n    r\"\"\"In general, we approximate the potential as\n\n    $\\hat{U} = \\sum_{j} \\beta_j(\\alpha) u_j$\n\n    For affine interactions (like those defined in this class) the basis\n    functions (or \"pillars), $u_j$, are just the \"naked\" parts of the\n    potential. As seen below, it is assumed that the $\\beta_j(\\alpha)$\n    coefficients are just the affine parameters, $\\alpha$, themselves.\n\n    Parameters:\n        rho_mesh (ndarray): discrete $\\rho$ values at which the potential is\n            going to be evaluated\n\n    Returns:\n        value (ndarray): values of the scaled potential at provided $\\rho$ points\n    \"\"\"\n    return np.array([self.tilde(rho_mesh, row) for row in np.eye(self.n_theta)]).T\n</code></pre>"},{"location":"interaction/#rose.interaction.Interaction.bundle_gcoeff_args","title":"<code>bundle_gcoeff_args(alpha)</code>","text":"<p>Bundles parameters for the Schr\u00f6dinger equation</p> <p>Returns:</p> Type Description <p>args (tuple) : all the arguments to g_coeff except for $s$</p> <p>Parameters:</p> Name Type Description Default <code>alpha (ndarray) </code> <p>the parameters for the interaction</p> required Source code in <code>src/rose/interaction.py</code> <pre><code>def bundle_gcoeff_args(self, alpha: np.array):\n    r\"\"\"Bundles parameters for the Schr\u00f6dinger equation\n\n    Returns:\n        args (tuple) : all the arguments to g_coeff except for $s$\n\n    Parameters:\n        alpha (ndarray) : the parameters for the interaction\n    \"\"\"\n    k = self.momentum(alpha)\n    S_C = self.coulomb_cutoff(alpha) * k\n    E = self.E(alpha)\n    eta = self.eta(alpha)\n    l = self.ell\n    v_r = self.v_r\n    l_dot_s = self.spin_orbit_term.l_dot_s\n    v_so = self.spin_orbit_term.v_so\n\n    return (alpha, k, S_C, E, eta, l, v_r, v_so, l_dot_s)\n</code></pre>"},{"location":"interaction/#rose.interaction.Interaction.coefficients","title":"<code>coefficients(alpha)</code>","text":"<p>As noted in the <code>basis_functions</code> documentation, the coefficients for affine interactions are simply the parameter values. The inverse of the momentum is also returned to support energy emulation.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter point</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>tuple</code> <p>inverse momentum and coefficients</p> Source code in <code>src/rose/interaction.py</code> <pre><code>def coefficients(self, alpha: np.array):  # interaction parameters\n    r\"\"\"As noted in the `basis_functions` documentation, the coefficients\n    for affine interactions are simply the parameter values. The inverse of\n    the momentum is also returned to support energy emulation.\n\n    Parameters:\n        alpha (ndarray): parameter point\n\n    Returns:\n        result (tuple): inverse momentum and coefficients\n\n    \"\"\"\n    return 1 / self.k, alpha\n</code></pre>"},{"location":"interaction/#rose.interaction.Interaction.coulomb_cutoff","title":"<code>coulomb_cutoff(alpha)</code>","text":"<p>Coulomb cutoff. Implemented as a function to support energy emulation (where the energy/momentum could be a part of the parameter vector, <code>alpha</code>).</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter vector</p> required <p>Returns:</p> Name Type Description <code>R_C</code> <code>float</code> <p>Coulomb cutoff</p> Source code in <code>src/rose/interaction.py</code> <pre><code>def coulomb_cutoff(self, alpha: np.array):\n    r\"\"\"Coulomb cutoff. Implemented as a function to support energy emulation\n    (where the energy/momentum could be a part of the parameter vector,\n    `alpha`).\n\n    Parameters:\n        alpha (ndarray): parameter vector\n\n    Returns:\n        R_C (float): Coulomb cutoff\n    \"\"\"\n    return self.R_C\n</code></pre>"},{"location":"interaction/#rose.interaction.Interaction.eta","title":"<code>eta(alpha)</code>","text":"<p>Sommerfeld parameter. Implemented as a function to support energy emulation (where the energy could be a part of the parameter vector, <code>alpha</code>).</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter vector</p> required <p>Returns:</p> Name Type Description <code>eta</code> <code>float</code> <p>Sommerfeld parameter</p> Source code in <code>src/rose/interaction.py</code> <pre><code>def eta(self, alpha: np.array):\n    r\"\"\"Sommerfeld parameter. Implemented as a function to support energy\n    emulation (where the energy could be a part of the parameter vector,\n    `alpha`).\n\n    Parameters:\n        alpha (ndarray): parameter vector\n\n    Returns:\n        eta (float): Sommerfeld parameter\n    \"\"\"\n    return self.sommerfeld\n</code></pre>"},{"location":"interaction/#rose.interaction.Interaction.momentum","title":"<code>momentum(alpha)</code>","text":"<p>Momentum. Implemented as a function to support energy emulation (where the energy/momentum could be a part of the parameter vector, <code>alpha</code>).</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter vector</p> required <p>Returns:</p> Name Type Description <code>k</code> <code>float</code> <p>center-of-mass, scattering momentum</p> Source code in <code>src/rose/interaction.py</code> <pre><code>def momentum(self, alpha: np.array):\n    r\"\"\"Momentum. Implemented as a function to support energy emulation\n    (where the energy/momentum could be a part of the parameter vector,\n    `alpha`).\n\n    Parameters:\n        alpha (ndarray): parameter vector\n\n    Returns:\n        k (float): center-of-mass, scattering momentum\n    \"\"\"\n    return self.k\n</code></pre>"},{"location":"interaction/#rose.interaction.Interaction.reduced_mass","title":"<code>reduced_mass(alpha)</code>","text":"<p>Mu. Implemented as a function to support energy emulation (where mu could be a part of the parameter vector, <code>alpha</code>).</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter vector</p> required <p>Returns:</p> Name Type Description <code>Mu</code> <code>float</code> <p>in [MeV/c^2]</p> Source code in <code>src/rose/interaction.py</code> <pre><code>def reduced_mass(self, alpha: np.array):\n    r\"\"\"Mu. Implemented as a function to support energy emulation (where mu could be a\n    part of the parameter vector, `alpha`).\n\n    Parameters:\n        alpha (ndarray): parameter vector\n\n    Returns:\n        Mu (float): in [MeV/c^2]\n    \"\"\"\n    return self.mu\n</code></pre>"},{"location":"interaction/#rose.interaction.Interaction.tilde","title":"<code>tilde(s, alpha)</code>","text":"<p>Scaled potential, $\\tilde{U}(s, \\alpha, E)$.</p> <ul> <li>Does not include the Coulomb term.</li> <li>$E = E_{c.m.}$; <code>[E] = MeV = [v_r]</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>float</code> <p>mesh point; $s = pr/\\hbar$</p> required <code>alpha</code> <code>ndarray</code> <p>the varied parameters</p> required <p>Returns:</p> Name Type Description <code>u_tilde</code> <code>float | complex</code> <p>value of scaled interaction</p> Source code in <code>src/rose/interaction.py</code> <pre><code>def tilde(self, s: float, alpha: np.array):\n    r\"\"\"Scaled potential, $\\tilde{U}(s, \\alpha, E)$.\n\n    * Does not include the Coulomb term.\n    * $E = E_{c.m.}$; `[E] = MeV = [v_r]`\n\n    Parameters:\n        s (float): mesh point; $s = pr/\\hbar$\n        alpha (ndarray): the varied parameters\n\n    Returns:\n        u_tilde (float | complex): value of scaled interaction\n\n    \"\"\"\n    vr = self.v_r(s / self.k, alpha) + self.spin_orbit_term.spin_orbit_potential(\n        s / self.k, alpha\n    )\n    return 1.0 / self.energy * vr\n</code></pre>"},{"location":"interaction/#rose.interaction.InteractionSpace","title":"<code>InteractionSpace(l_max=15, interaction_type=Interaction, **kwargs)</code>","text":"<p>Generates a list of $\\ell$-specific interactions.</p> <p>Parameters:</p> Name Type Description Default <code>l_max</code> <code>int</code> <p>maximum angular momentum</p> <code>15</code> <code>interaction_type</code> <code>Type</code> <p>type of <code>Interaction</code> to construct</p> <code>Interaction</code> <code>kwargs</code> <code>dict</code> <p>arguments to constructor of <code>interaction_type</code></p> <code>{}</code> <p>Returns:</p> Name Type Description <code>instance</code> <code>InteractionSpace</code> <p>instance of InteractionSpace</p> <p>Attributes:</p> Name Type Description <code>interaction</code> <code>list</code> <p>list of <code>Interaction</code>s</p> <code>l_max</code> <code>int</code> <p>partial wave cutoff</p> <code>type</code> <code>Type</code> <p>interaction type</p> Source code in <code>src/rose/interaction.py</code> <pre><code>def __init__(\n    self,\n    l_max: int = 15,\n    interaction_type=Interaction,\n    **kwargs,\n):\n    r\"\"\"Generates a list of $\\ell$-specific interactions.\n\n    Parameters:\n        l_max (int): maximum angular momentum\n        interaction_type (Type): type of `Interaction` to construct\n        kwargs (dict): arguments to constructor of `interaction_type`\n\n    Returns:\n        instance (InteractionSpace): instance of InteractionSpace\n\n    Attributes:\n        interaction (list): list of `Interaction`s\n        l_max (int): partial wave cutoff\n        type (Type): interaction type\n    \"\"\"\n    self.l_max = l_max\n    self.type = interaction_type\n    self.interactions = []\n\n    if \"spin_orbit_term\" not in kwargs:\n        for l in range(self.l_max + 1):\n            self.interactions.append([self.type(ell=l, **kwargs)])\n    else:\n        spin_orbit_potential = kwargs[\"spin_orbit_term\"]\n        kwargs.pop(\"spin_orbit_term\")\n\n        for l in range(self.l_max + 1):\n            self.interactions.append(\n                [\n                    self.type(\n                        ell=l,\n                        spin_orbit_term=SpinOrbitTerm(spin_orbit_potential, lds),\n                        **kwargs,\n                    )\n                    for lds in couplings(l)\n                ]\n            )\n</code></pre>"},{"location":"interaction/#rose.interaction.couplings","title":"<code>couplings(l)</code>","text":"<p>For a spin-1/2 nucleon scattering off a spin-0 nucleus, there are maximally 2 different total angular momentum couplings: l+1/2 and l-1/2.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>int</code> <p>angular momentum</p> required <p>Returns:</p> Name Type Description <code>couplings</code> <code>list</code> <p>epectation value of l dot s</p> Source code in <code>src/rose/interaction.py</code> <pre><code>def couplings(l):\n    r\"\"\"For a spin-1/2 nucleon scattering off a spin-0 nucleus, there are\n    maximally 2 different total angular momentum couplings: l+1/2 and l-1/2.\n\n    Parameters:\n        l (int): angular momentum\n\n    Returns:\n        couplings (list): epectation value of l dot s\n    \"\"\"\n    js = [l + 1.0 / 2] if l == 0 else [l + 1.0 / 2, l - 1.0 / 2]\n    return [(j * (j + 1) - l * (l + 1) - 0.5 * (0.5 + 1)) for j in js]\n</code></pre>"},{"location":"interaction/#non-affine-fixed-energy-interactions","title":"Non-Affine, Fixed-Energy Interactions","text":"<p>Interactions that leverage the Empirical Interpolation Method (EIM) to allow the emulation of parameters in which the coordinate-space potential is not affine.</p>"},{"location":"interaction/#rose.interaction_eim.InteractionEIM","title":"<code>InteractionEIM(training_info=None, n_basis=None, expl_var_ratio_cutoff=None, explicit_training=False, n_train=1000, rho_mesh=DEFAULT_RHO_MESH, match_points=None, method='collocation', **kwargs)</code>","text":"<p>               Bases: <code>Interaction</code></p> <p>Parameters:</p> Name Type Description Default <code>training_info</code> <code>ndarray</code> <p>Either (1) parameters bounds or (2) explicit training points</p> <p>If (1):     This is a 2-column matrix. The first column are the lower     bounds. The second are the upper bounds. Each row maps to a     single parameter.</p> <p>If (2):     This is an MxN matrix. N is the number of parameters. M is     the number of samples.</p> <code>None</code> <code>n_basis</code> <code>int</code> <p>min number of states in the expansion</p> <code>None</code> <code>expl_var_ratio_cutoff (float) </code> <p>the cutoff in sv2/sum(sv2), sv being the singular values, at which the number of kept bases is chosen</p> required <code>explicit_training</code> <code>bool</code> <p>Is training_info (1) or (2)? (1) is default</p> <code>False</code> <code>n_train</code> <code>int</code> <p>How many snapshots to generate? Ignored if explicit_training is True.</p> <code>1000</code> <code>rho_mesh</code> <code>ndarray</code> <p>coordinate-space points at which the interaction is generated (used for training)</p> <code>DEFAULT_RHO_MESH</code> <code>match_points</code> <code>ndarray</code> <p>$\\rho$ points where agreement with the true potential is enforced</p> <code>None</code> <code>method (str) </code> <p>'collocation' or 'least-squares'. If 'collocation', match_points must be the same length as n_basis; otherwise match_points can be any size.</p> required <code>kwargs</code> <code>dict</code> <p>kwargs to <code>Interaction.__init__</code></p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>s_mesh</code> <code>ndarray</code> <p>$s$ points</p> <code>singular_values</code> <code>ndarray</code> <p><code>S</code> in <code>U, S, Vt = numpy.linalg.svd(...)</code></p> <code>snapshots</code> <code>ndarray</code> <p>pillars, columns of <code>U</code></p> <code>match_indices</code> <code>ndarray</code> <p>indices of points in $\\rho$ mesh that are matched to the true potential</p> <code>match_points</code> <code>ndarray</code> <p>points in $\\rho$ mesh that are matched to the true potential</p> <code>Ainv</code> <code>ndarray</code> <p>inverse of A matrix (Ax = b)</p> Source code in <code>src/rose/interaction_eim.py</code> <pre><code>def __init__(\n    self,\n    training_info: np.array = None,\n    n_basis: int = None,\n    expl_var_ratio_cutoff: float = None,\n    explicit_training: bool = False,\n    n_train: int = 1000,\n    rho_mesh: np.array = DEFAULT_RHO_MESH,\n    match_points: np.array = None,\n    method=\"collocation\",\n    **kwargs,\n):\n    r\"\"\"\n    Parameters:\n        training_info (ndarray): Either (1) parameters bounds or (2)\n            explicit training points\n\n            If (1):\n                This is a 2-column matrix. The first column are the lower\n                bounds. The second are the upper bounds. Each row maps to a\n                single parameter.\n\n            If (2):\n                This is an MxN matrix. N is the number of parameters. M is\n                the number of samples.\n        n_basis (int): min number of states in the expansion\n        expl_var_ratio_cutoff (float) : the cutoff in sv**2/sum(sv**2), sv\n            being the singular values, at which the number of kept bases is chosen\n        explicit_training (bool): Is training_info (1) or (2)? (1) is\n            default\n        n_train (int): How many snapshots to generate? Ignored if\n            explicit_training is True.\n        rho_mesh (ndarray): coordinate-space points at which the interaction\n            is generated (used for training)\n        match_points (ndarray): $\\rho$ points where agreement with the true\n            potential is enforced\n        method (str) : 'collocation' or 'least-squares'. If 'collocation',\n            match_points must be the same length as n_basis; otherwise match_points\n            can be any size.\n        kwargs (dict): kwargs to `Interaction.__init__`\n\n    Attributes:\n        s_mesh (ndarray): $s$ points\n        singular_values (ndarray): `S` in `U, S, Vt = numpy.linalg.svd(...)`\n        snapshots (ndarray): pillars, columns of `U`\n        match_indices (ndarray): indices of points in $\\rho$ mesh that are\n            matched to the true potential\n        match_points (ndarray): points in $\\rho$ mesh that are matched to\n            the true potential\n        Ainv (ndarray): inverse of A matrix (Ax = b)\n    \"\"\"\n    assert training_info is not None\n\n    if n_basis is None:\n        if \"n_theta\" in kwargs:\n            n_basis = kwargs[\"n_theta\"]\n        else:\n            n_basis = 8\n\n    super().__init__(**kwargs)\n\n    self.method = method\n    self.n_train = n_train\n    self.n_basis = n_basis\n    self.training_info = training_info\n    self.s_mesh = rho_mesh\n\n    # Generate a basis used to approximate the potential.\n    # Did the user specify the training points?\n    if explicit_training:\n        snapshots = np.array(\n            [self.tilde(rho_mesh, theta) for theta in training_info]\n        ).T\n    else:\n        train = latin_hypercube_sample(n_train, training_info)\n        snapshots = np.array([self.tilde(rho_mesh, theta) for theta in train]).T\n\n    U, S, _ = np.linalg.svd(snapshots, full_matrices=False)\n\n    # keeping at min n_basis PC's, find cutoff\n    # avoids singular matrix in MAXVOL when we find a region of param\n    # space w/ very similar potentials\n    self.singular_values = S\n    if expl_var_ratio_cutoff is not None:\n        expl_var = self.singular_values**2 / np.sum(self.singular_values**2)\n        n_basis_svs = np.sum(expl_var &gt; expl_var_ratio_cutoff)\n        self.n_basis = max(n_basis_svs, self.n_basis)\n    else:\n        self.n_basis = n_basis\n\n    self.snapshots = U[:, : self.n_basis]\n    self.match_points = match_points\n\n    if match_points is not None and method == \"collocation\":\n        self.n_basis = match_points.size\n        self.match_points = match_points\n        self.match_indices = np.array(\n            [np.argmin(np.abs(rho_mesh - ri)) for ri in self.match_points]\n        )\n        self.r_i = rho_mesh[self.match_indices]\n        self.Ainv = np.linalg.inv(self.snapshots[self.match_indices])\n    elif match_points is None and method == \"collocation\":\n        # random r points between 0 and 2\u03c0 fm\n        i_max = self.snapshots.shape[0] // 4\n        di = i_max // (self.n_basis - 1)\n        i_init = np.arange(0, i_max + 1, di)\n        self.match_indices = max_vol(self.snapshots, i_init)\n        self.match_points = rho_mesh[self.match_indices]\n        self.r_i = self.match_points\n        self.Ainv = np.linalg.inv(self.snapshots[self.match_indices])\n    elif method == \"least-squares\":\n        if match_points is None:\n            self.match_points = rho_mesh\n        else:\n            self.match_points = match_points\n        self.match_indices = np.array(\n            [find_nearest_idx(self.s_mesh, x) for x in self.match_points]\n        )\n        self.match_points = self.s_mesh[self.match_indices]\n        self.r_i = self.match_points\n        self.Ainv = np.linalg.pinv(self.snapshots[self.match_indices])\n    else:\n        raise ValueError(\n            \"argument 'method' should be one of `collocation` or `least-squares`\"\n        )\n</code></pre>"},{"location":"interaction/#rose.interaction_eim.InteractionEIM.basis_functions","title":"<code>basis_functions(s_mesh)</code>","text":"<p>$u_j$ in $\\tilde{U} \\approx \\hat{U} \\equiv \\sum_j \\beta_j(\\alpha) u_j$</p> <p>Parameters:</p> Name Type Description Default <code>s_mesh</code> <code>ndarray</code> <p>$s$ mesh points</p> required <p>Returns:</p> Name Type Description <code>u_j</code> <code>ndarray</code> <p>\"pillars\" (MxN matrix; M = number of mesh points; N = number of pillars)</p> Source code in <code>src/rose/interaction_eim.py</code> <pre><code>def basis_functions(self, s_mesh: np.array):\n    r\"\"\"$u_j$ in $\\tilde{U} \\approx \\hat{U} \\equiv \\sum_j \\beta_j(\\alpha) u_j$\n\n    Parameters:\n        s_mesh (ndarray): $s$ mesh points\n\n    Returns:\n        u_j (ndarray): \"pillars\" (MxN matrix; M = number of mesh points; N = number of pillars)\n\n    \"\"\"\n    return np.copy(self.snapshots)\n</code></pre>"},{"location":"interaction/#rose.interaction_eim.InteractionEIM.coefficients","title":"<code>coefficients(alpha)</code>","text":"<p>Computes the EIM expansion coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>interaction parameters</p> required <p>Returns:</p> Name Type Description <code>coefficients</code> <code>ndarray</code> <p>EIM expansion coefficients</p> Source code in <code>src/rose/interaction_eim.py</code> <pre><code>def coefficients(self, alpha: np.array):\n    r\"\"\"Computes the EIM expansion coefficients.\n\n    Parameters:\n        alpha (ndarray): interaction parameters\n\n    Returns:\n        coefficients (ndarray): EIM expansion coefficients\n\n    \"\"\"\n    u_true = self.tilde(self.r_i, alpha)\n    return 1 / self.k, self.Ainv @ u_true\n</code></pre>"},{"location":"interaction/#rose.interaction_eim.InteractionEIM.percent_explained_variance","title":"<code>percent_explained_variance(n=None)</code>","text":"<p>Returns:</p> Type Description <p>(float) : percent of variance explained in the training set by the first n_basis principal</p> <p>components</p> Source code in <code>src/rose/interaction_eim.py</code> <pre><code>def percent_explained_variance(self, n=None):\n    r\"\"\"\n    Returns:\n        (float) : percent of variance explained in the training set by the first n_basis principal\n        components\n    \"\"\"\n    if n is None:\n        n = self.n_basis\n    return (\n        100\n        * np.sum(self.singular_values[:n] ** 2)\n        / np.sum(self.singular_values**2)\n    )\n</code></pre>"},{"location":"interaction/#rose.interaction_eim.InteractionEIM.tilde_emu","title":"<code>tilde_emu(alpha)</code>","text":"<p>Emulated interaction = $\\hat{U}(s, \\alpha, E)$</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>interaction parameters</p> required <p>Returns:</p> Name Type Description <code>u_hat</code> <code>ndarray</code> <p>emulated interaction</p> Source code in <code>src/rose/interaction_eim.py</code> <pre><code>def tilde_emu(self, alpha: np.array):\n    r\"\"\"Emulated interaction = $\\hat{U}(s, \\alpha, E)$\n\n    Parameters:\n        alpha (ndarray): interaction parameters\n\n    Returns:\n        u_hat (ndarray): emulated interaction\n\n    \"\"\"\n    _, x = self.coefficients(alpha)\n    emu = np.sum(x * self.snapshots, axis=1)\n    return emu\n</code></pre>"},{"location":"interaction/#rose.interaction_eim.InteractionEIMSpace","title":"<code>InteractionEIMSpace(l_max=15, interaction_type=InteractionEIM, **kwargs)</code>","text":"<p>               Bases: <code>InteractionSpace</code></p> <p>Generates a list of $\\ell$-specific, EIMed interactions.</p> <p>Parameters:</p> Name Type Description Default <code>interaction_args</code> <code>list</code> <p>positional arguments for constructor of <code>interaction_type</code></p> required <code>interaction_kwargs</code> <code>dict</code> <p>arguments to constructor of <code>interaction_type</code></p> required <code>l_max</code> <code>int</code> <p>maximum angular momentum</p> <code>15</code> <code>interaction_type</code> <code>Type</code> <p>type of <code>Interaction</code> to construct</p> <code>InteractionEIM</code> <p>Returns:</p> Name Type Description <code>instance</code> <code>InteractionEIMSpace</code> <p>instance of InteractionEIMSpace</p> <p>Attributes:</p> Name Type Description <code>interaction</code> <code>list</code> <p>list of <code>Interaction</code>s</p> <code>l_max</code> <code>int</code> <p>partial wave cutoff</p> <code>type</code> <code>Type</code> <p>interaction type</p> Source code in <code>src/rose/interaction_eim.py</code> <pre><code>def __init__(\n    self,\n    l_max: int = 15,\n    interaction_type=InteractionEIM,\n    **kwargs,\n):\n    r\"\"\"Generates a list of $\\ell$-specific, EIMed interactions.\n\n    Parameters:\n        interaction_args (list): positional arguments for constructor of `interaction_type`\n        interaction_kwargs (dict): arguments to constructor of `interaction_type`\n        l_max (int): maximum angular momentum\n        interaction_type (Type): type of `Interaction` to construct\n\n    Returns:\n        instance (InteractionEIMSpace): instance of InteractionEIMSpace\n\n    Attributes:\n        interaction (list): list of `Interaction`s\n        l_max (int): partial wave cutoff\n        type (Type): interaction type\n    \"\"\"\n    super().__init__(interaction_type=interaction_type, l_max=l_max, **kwargs)\n</code></pre>"},{"location":"interaction/#non-affine-energy-emulated-interactions","title":"Non-Affine, Energy-Emulated Interactions","text":"<p>Defines a class for \"affinizing\" Interactions using the Empirical Interpolation Method (EIM).</p>"},{"location":"interaction/#rose.energized_interaction_eim.EnergizedInteractionEIM","title":"<code>EnergizedInteractionEIM(**kwargs)</code>","text":"<p>               Bases: <code>InteractionEIM</code></p> <p>Extension of InteractionEIM that supports energy, mu and k as parameters. Expected format for alpha is [energy, mu, k, *rest_of_params]</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>arguments to InteractionEIM. Note; the <code>energy</code> argument should not</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>singular_values</code> <code>ndarray</code> <p><code>S</code> in <code>U, S, Vt = numpy.linalg.svd(...)</code></p> <code>snapshots</code> <code>ndarray</code> <p>pillars, columns of <code>U</code></p> <code>match_indices</code> <code>ndarray</code> <p>indices of points in $\\rho$ mesh that are matched to the true potential</p> <code>match_points</code> <code>ndarray</code> <p>points in $\\rho$ mesh that are matched to the true potential</p> <code>Ainv</code> <code>ndarray</code> <p>inverse of A matrix (Ax = b)</p> Source code in <code>src/rose/energized_interaction_eim.py</code> <pre><code>def __init__(\n    self,\n    **kwargs,\n):\n    r\"\"\"\n    Parameters:\n        kwargs (dict): arguments to InteractionEIM. Note; the `energy` argument should not\n        be given, it will be ignored. Energy is the first element of alpha. If `mu is None`,\n        the reduced mass will expected to be the second element of alpha.\n\n    Attributes:\n        singular_values (ndarray): `S` in `U, S, Vt = numpy.linalg.svd(...)`\n        snapshots (ndarray): pillars, columns of `U`\n        match_indices (ndarray): indices of points in $\\rho$ mesh that are\n            matched to the true potential\n        match_points (ndarray): points in $\\rho$ mesh that are matched to\n            the true potential\n        Ainv (ndarray): inverse of A matrix (Ax = b)\n    \"\"\"\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"interaction/#rose.energized_interaction_eim.EnergizedInteractionEIM.E","title":"<code>E(alpha)</code>","text":"<p>Energy. Implemented as a function to support energy emulation (where the energy could be a part of the parameter vector, <code>alpha</code>).</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter vector</p> required <p>Returns:</p> Name Type Description <code>Energy</code> <code>float</code> <p>in [MeV]</p> Source code in <code>src/rose/energized_interaction_eim.py</code> <pre><code>def E(self, alpha: np.array):\n    r\"\"\"Energy. Implemented as a function to support energy emulation (where the energy\n    could be a part of the parameter vector, `alpha`).\n\n    Parameters:\n        alpha (ndarray): parameter vector\n\n    Returns:\n        Energy (float): in [MeV]\n    \"\"\"\n    return alpha[0]\n</code></pre>"},{"location":"interaction/#rose.energized_interaction_eim.EnergizedInteractionEIM.basis_functions","title":"<code>basis_functions(s_mesh)</code>","text":"<p>$u_j$ in $\\tilde{U} \\approx \\hat{U} \\equiv \\sum_j \\beta_j(\\alpha) u_j$</p> <p>Parameters:</p> Name Type Description Default <code>s_mesh</code> <code>ndarray</code> <p>$s$ mesh points</p> required <p>Returns:</p> Name Type Description <code>u_j</code> <code>ndarray</code> <p>\"pillars\" (MxN matrix; M = number of mesh points; N = number of pillars)</p> Source code in <code>src/rose/energized_interaction_eim.py</code> <pre><code>def basis_functions(self, s_mesh: np.array):\n    r\"\"\"$u_j$ in $\\tilde{U} \\approx \\hat{U} \\equiv \\sum_j \\beta_j(\\alpha) u_j$\n\n    Parameters:\n        s_mesh (ndarray): $s$ mesh points\n\n    Returns:\n        u_j (ndarray): \"pillars\" (MxN matrix; M = number of mesh points; N = number of pillars)\n\n    \"\"\"\n    return np.copy(self.snapshots)\n</code></pre>"},{"location":"interaction/#rose.energized_interaction_eim.EnergizedInteractionEIM.bundle_gcoeff_args","title":"<code>bundle_gcoeff_args(alpha)</code>","text":"<p>Bundles parameters for the Schr\u00f6dinger equation</p> <p>Returns:</p> Type Description <p>args (tuple) : all the arguments to g_coeff except for $s$</p> <p>Parameters:</p> Name Type Description Default <code>alpha (ndarray) </code> <p>the parameters for the interaction</p> required Source code in <code>src/rose/energized_interaction_eim.py</code> <pre><code>def bundle_gcoeff_args(self, alpha: np.array):\n    r\"\"\"Bundles parameters for the Schr\u00f6dinger equation\n\n    Returns:\n        args (tuple) : all the arguments to g_coeff except for $s$\n\n    Parameters:\n        alpha (ndarray) : the parameters for the interaction\n    \"\"\"\n    k = self.momentum(alpha)\n    S_C = self.coulomb_cutoff(alpha) * k\n    E = self.E(alpha)\n    eta = self.eta(alpha)\n    l = self.ell\n    v_r = self.v_r\n    l_dot_s = self.spin_orbit_term.l_dot_s\n\n    # remove the energy term for alpha, so we return just the parameters that plug into v_r\n    return (alpha[3:], k, S_C, E, eta, l, v_r, self.spin_orbit_term.v_so, l_dot_s)\n</code></pre>"},{"location":"interaction/#rose.energized_interaction_eim.EnergizedInteractionEIM.coefficients","title":"<code>coefficients(alpha)</code>","text":"<p>Computes the EIM expansion coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>interaction parameters</p> required <p>Returns:</p> Name Type Description <code>coefficients</code> <code>ndarray</code> <p>EIM expansion coefficients</p> Source code in <code>src/rose/energized_interaction_eim.py</code> <pre><code>def coefficients(self, alpha: np.array):  # interaction parameters\n    r\"\"\"Computes the EIM expansion coefficients.\n\n    Parameters:\n        alpha (ndarray): interaction parameters\n\n    Returns:\n        coefficients (ndarray): EIM expansion coefficients\n\n    \"\"\"\n    k = self.momentum(alpha)\n    u_true = self.tilde(self.r_i, alpha)\n    return 1 / k, self.Ainv @ u_true\n</code></pre>"},{"location":"interaction/#rose.energized_interaction_eim.EnergizedInteractionEIM.eta","title":"<code>eta(alpha)</code>","text":"<p>Returns the Sommerfeld parameter.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>interaction parameters</p> required <p>Returns:</p> Name Type Description <code>eta</code> <code>float</code> <p>Sommerfeld parameter</p> Source code in <code>src/rose/energized_interaction_eim.py</code> <pre><code>def eta(self, alpha: np.array):\n    r\"\"\"Returns the Sommerfeld parameter.\n\n    Parameters:\n        alpha (ndarray): interaction parameters\n\n    Returns:\n        eta (float): Sommerfeld parameter\n\n    \"\"\"\n    return self.k_c / self.momentum(alpha)\n</code></pre>"},{"location":"interaction/#rose.energized_interaction_eim.EnergizedInteractionEIM.momentum","title":"<code>momentum(alpha)</code>","text":"<p>Center-of-mass, scattering momentum. Implemented as a function to support energy emulation (where k could be a part of the parameter vector, <code>alpha</code>).</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>interaction parameters</p> required <p>Returns:</p> Name Type Description <code>k</code> <code>float</code> <p>momentum</p> Source code in <code>src/rose/energized_interaction_eim.py</code> <pre><code>def momentum(self, alpha: np.array):\n    r\"\"\"Center-of-mass, scattering momentum. Implemented as a function to support energy\n    emulation (where k could be a part of the parameter vector, `alpha`).\n\n    Parameters:\n        alpha (ndarray): interaction parameters\n\n    Returns:\n        k (float): momentum\n    \"\"\"\n    return alpha[2]\n</code></pre>"},{"location":"interaction/#rose.energized_interaction_eim.EnergizedInteractionEIM.reduced_mass","title":"<code>reduced_mass(alpha)</code>","text":"<p>Mu. Implemented as a function to support energy emulation (where mu could be a part of the parameter vector, <code>alpha</code>).</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter vector</p> required <p>Returns:</p> Name Type Description <code>Mu</code> <code>float</code> <p>in [MeV/c^2]</p> Source code in <code>src/rose/energized_interaction_eim.py</code> <pre><code>def reduced_mass(self, alpha: np.array):\n    r\"\"\"Mu. Implemented as a function to support energy emulation (where mu could be a\n    part of the parameter vector, `alpha`).\n\n    Parameters:\n        alpha (ndarray): parameter vector\n\n    Returns:\n        Mu (float): in [MeV/c^2]\n    \"\"\"\n    return alpha[1]\n</code></pre>"},{"location":"interaction/#rose.energized_interaction_eim.EnergizedInteractionEIM.tilde","title":"<code>tilde(s, alpha)</code>","text":"<p>Computes the energy-scaled interaction.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>float</code> <p>mesh point</p> required <code>alpha</code> <code>ndarray</code> <p>interaction parameters</p> required <p>Returns:</p> Name Type Description <code>u_tilde</code> <code>float | complex</code> <p>energy-scaled interaction</p> Source code in <code>src/rose/energized_interaction_eim.py</code> <pre><code>def tilde(self, s: float, alpha: np.array):\n    r\"\"\"Computes the energy-scaled interaction.\n\n    Parameters:\n        s (float): mesh point\n        alpha (ndarray): interaction parameters\n\n    Returns:\n        u_tilde (float | complex): energy-scaled interaction\n\n    \"\"\"\n    energy = self.E(alpha)\n    k = self.momentum(alpha)\n    alpha_truncated = alpha[3:]\n    vr = self.v_r(\n        s / k, alpha_truncated\n    ) + self.spin_orbit_term.spin_orbit_potential(s / k, alpha_truncated)\n    return 1.0 / energy * vr\n</code></pre>"},{"location":"interaction/#rose.energized_interaction_eim.EnergizedInteractionEIM.tilde_emu","title":"<code>tilde_emu(s, alpha)</code>","text":"<p>Emulated interaction = $\\hat{U}(s, \\alpha, E)$</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>interaction parameters</p> required <p>Returns:</p> Name Type Description <code>u_hat</code> <code>ndarray</code> <p>emulated interaction</p> Source code in <code>src/rose/energized_interaction_eim.py</code> <pre><code>def tilde_emu(self, s: float, alpha: np.array):\n    r\"\"\"Emulated interaction = $\\hat{U}(s, \\alpha, E)$\n\n    Parameters:\n        alpha (ndarray): interaction parameters\n\n    Returns:\n        u_hat (ndarray): emulated interaction\n\n    \"\"\"\n    _, x = self.coefficients(alpha)\n    emu = np.sum(x * self.snapshots, axis=1)\n    return emu\n</code></pre>"},{"location":"interaction/#rose.energized_interaction_eim.EnergizedInteractionEIMSpace","title":"<code>EnergizedInteractionEIMSpace(l_max=15, interaction_type=EnergizedInteractionEIM, **kwargs)</code>","text":"<p>               Bases: <code>InteractionEIMSpace</code></p> <p>Generates a list of $\\ell$-specific interactions.</p> <p>Parameters:</p> Name Type Description Default <code>interaction_args</code> <code>list</code> <p>positional arguments for constructor of <code>interaction_type</code></p> required <code>interaction_kwargs</code> <code>dict</code> <p>arguments to constructor of <code>interaction_type</code></p> required <code>l_max</code> <code>int</code> <p>maximum angular momentum</p> <code>15</code> <code>interaction_type</code> <code>Type</code> <p>type of <code>Interaction</code> to construct</p> <code>EnergizedInteractionEIM</code> <p>Returns:</p> Name Type Description <code>instance</code> <code>EnergizedInteractionEIMSpaceInteractionSpace</code> <p>instance of EnergizedInteractionEIMSpace</p> <p>Attributes:</p> Name Type Description <code>interaction</code> <code>list</code> <p>list of <code>Interaction</code>s</p> <code>l_max</code> <code>int</code> <p>partial wave cutoff</p> <code>type</code> <code>Type</code> <p>interaction type</p> Source code in <code>src/rose/energized_interaction_eim.py</code> <pre><code>def __init__(\n    self,\n    l_max: int = 15,\n    interaction_type=EnergizedInteractionEIM,\n    **kwargs,\n):\n    r\"\"\"Generates a list of $\\ell$-specific interactions.\n\n    Parameters:\n        interaction_args (list): positional arguments for constructor of `interaction_type`\n        interaction_kwargs (dict): arguments to constructor of `interaction_type`\n        l_max (int): maximum angular momentum\n        interaction_type (Type): type of `Interaction` to construct\n\n    Returns:\n        instance (EnergizedInteractionEIMSpaceInteractionSpace):\n            instance of EnergizedInteractionEIMSpace\n\n    Attributes:\n        interaction (list): list of `Interaction`s\n        l_max (int): partial wave cutoff\n        type (Type): interaction type\n    \"\"\"\n    super().__init__(\n        interaction_type=interaction_type,\n        l_max=l_max,\n        **kwargs,\n    )\n</code></pre>"},{"location":"interaction/#spin-orbit","title":"Spin-Orbit","text":"<p>Defines a class to package the spin-orbit term.</p>"},{"location":"interaction/#rose.spin_orbit.SpinOrbitTerm","title":"<code>SpinOrbitTerm(spin_orbit_potential=None, l_dot_s=None)</code>","text":"<p>Spin-orbit interaction</p> <p>Parameters:</p> Name Type Description Default <code>spin_orbit_potential</code> <code>Callable[[float, ndarray, float], float]</code> <p>coordinate-space, spin-orbit potential</p> <code>None</code> <code>l_dot_s</code> <code>float</code> <p>$2\\ell\\cdot s$ matrix elements, $+\\ell$ or $-\\ell-1$</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>l_dot_s</code> <code>float</code> <p>$2\\ell\\cdot s$ matrix elements, $+\\ell$ or $-\\ell-1$</p> <code>spin_orbit_potential</code> <code>float</code> <p>(Callable[[float, ndarray, float],float]): coordinate-space, spin-orbit potential</p> Source code in <code>src/rose/spin_orbit.py</code> <pre><code>def __init__(\n    self,\n    spin_orbit_potential: Callable[[float, np.array, float], float] = None,\n    l_dot_s: float = None,\n):\n    r\"\"\"Spin-orbit interaction\n\n    Parameters:\n        spin_orbit_potential (Callable[[float, ndarray, float],float]):\n            coordinate-space, spin-orbit potential\n        l_dot_s (float): $2\\ell\\cdot s$ matrix elements, $+\\ell$ or $-\\ell-1$\n\n    Attributes:\n        l_dot_s (float): $2\\ell\\cdot s$ matrix elements, $+\\ell$ or $-\\ell-1$\n        spin_orbit_potential: (Callable[[float, ndarray, float],float]):\n            coordinate-space, spin-orbit potential\n\n    \"\"\"\n    self.l_dot_s = l_dot_s\n    self.v_so = spin_orbit_potential\n\n    if spin_orbit_potential is None:\n        self.l_dot_s = 0\n        self.v_so = v_so_default\n</code></pre>"},{"location":"interaction/#koning-delaroche","title":"Koning-Delaroche","text":"<p>The Koning-Delaroche potential is a common optical potential for nuclear scattering. It is provided here in simplified form specifically to address this need.</p> <p>See the Koning-Delaroche paper for details. Equation references are with respect to (w.r.t.) this paper.</p>"},{"location":"interaction/#rose.koning_delaroche.EnergizedKoningDelaroche","title":"<code>EnergizedKoningDelaroche(training_info, l_max=20, n_basis=8, explicit_training=False, n_train=1000, rho_mesh=DEFAULT_RHO_MESH, match_points=None, method='collocation', **kwargs)</code>","text":"<p>               Bases: <code>EnergizedInteractionEIMSpace</code></p> <p>Wraps the Koning-Delaroche potential into a <code>rose</code>-friendly class. Saves system-specific information. Allows the user to emulate across energies.</p> <ul> <li>Does not (yet) support Coulomb.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>float</code> <p>reduced mass of the 2-body system</p> required <code>ell</code> <code>int</code> <p>angular momentum</p> required <code>training_info</code> <code>ndarray</code> <p>either (1) parameters bounds or (2) explicit training points</p> <p>If (1): This is a 2-column matrix. The first column are the lower bounds. The second are the upper bounds. Each row maps to a single parameter.</p> <p>If (2): This is an MxN matrix. N is the number of parameters. M is the number of samples.</p> required <code>n_basis</code> <code>int</code> <p>number of basis states to use for EIM</p> <code>8</code> <code>explicit_training</code> <code>bool</code> <p>True implies training_info case (2); False implies (1)</p> <code>False</code> <code>n_train</code> <code>int</code> <p>how many training samples to use</p> <code>1000</code> <code>rho_mesh</code> <code>ndarray</code> <p>$\\rho$ (or $s$) grid values</p> <code>DEFAULT_RHO_MESH</code> <code>match_points</code> <code>ndarray</code> <p>$\\rho$ points at which we demand the EIMed potential match the true potential</p> <code>None</code> <p>Returns:</p> Name Type Description <code>instance</code> <code>EnergizedKoningDelaroche</code> <p>instance of the class</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>def __init__(\n    self,\n    training_info: np.array,\n    l_max=20,\n    n_basis: int = 8,\n    explicit_training: bool = False,\n    n_train: int = 1000,\n    rho_mesh: np.array = DEFAULT_RHO_MESH,\n    match_points: np.array = None,\n    method=\"collocation\",\n    **kwargs,\n):\n    r\"\"\"Wraps the Koning-Delaroche potential into a `rose`-friendly class.\n    Saves system-specific information. Allows the user to emulate across\n    energies.\n\n    * **Does not (yet) support Coulomb.**\n\n    Parameters:\n        mu (float): reduced mass of the 2-body system\n        ell (int): angular momentum\n        training_info (ndarray): either (1) parameters bounds or (2) explicit training points\n\n            If (1):\n            This is a 2-column matrix. The first column are the lower\n            bounds. The second are the upper bounds. Each row maps to a\n            single parameter.\n\n            If (2):\n            This is an MxN matrix. N is the number of parameters. M is the\n            number of samples.\n        n_basis (int): number of basis states to use for EIM\n        explicit_training (bool): True implies training_info case (2); False implies (1)\n        n_train (int): how many training samples to use\n        rho_mesh (ndarray):  $\\rho$ (or $s$) grid values\n        match_points (ndarray): $\\rho$ points at which we demand the EIMed\n            potential match the true potential\n\n    Returns:\n        instance (EnergizedKoningDelaroche): instance of the class\n    \"\"\"\n    n_params = NUM_PARAMS + 3  # include mu, k, and energy\n\n    super().__init__(\n        l_max=l_max,\n        coordinate_space_potential=KD_simple,\n        n_theta=n_params,\n        training_info=training_info,\n        Z_1=0,\n        Z_2=0,\n        is_complex=True,\n        spin_orbit_term=KD_simple_so,\n        n_basis=n_basis,\n        explicit_training=explicit_training,\n        n_train=n_train,\n        rho_mesh=rho_mesh,\n        match_points=match_points,\n        method=method,\n        **kwargs,\n    )\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.KDGlobal","title":"<code>KDGlobal(projectile, param_fpath=None)</code>","text":"<p>Global optical potential in Koning-Delaroche form.</p> <p>Parameters:</p> Name Type Description Default <code>projectile </code> <p>neutron or proton?</p> required <code>param_fpath </code> <p>path to json file encoding parameter values.</p> required Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>def __init__(self, projectile: Projectile, param_fpath: Path = None):\n    r\"\"\"\n    Parameters:\n        projectile : neutron or proton?\n        param_fpath : path to json file encoding parameter values.\n        Defaults to data/KD_default.json\n    \"\"\"\n    if param_fpath is None:\n        param_fpath = Path(__file__).parent.resolve() / Path(\n            \"../data/KD_default.json\"\n        )\n\n    if projectile == Projectile.neutron:\n        tag = \"_n\"\n    elif projectile == Projectile.proton:\n        tag = \"_p\"\n    else:\n        raise RuntimeError(\n            \"KDGlobal is defined only for neutron and proton projectiles\"\n        )\n\n    self.projectile = projectile\n\n    self.param_fpath = param_fpath\n    with open(self.param_fpath) as f:\n        data = json.load(f)\n\n        if \"KDHartreeFock\" in data:\n            # real central depth\n            self.v1_0 = data[\"KDHartreeFock\"][\"V1_0\"]\n            self.v1_asymm = data[\"KDHartreeFock\"][\"V1_asymm\"]\n            self.v1_A = data[\"KDHartreeFock\"][\"V1_A\"]\n            self.v2_0 = data[\"KDHartreeFock\"][\"V2_0\" + tag]\n            self.v2_A = data[\"KDHartreeFock\"][\"V2_A\" + tag]\n            self.v3_0 = data[\"KDHartreeFock\"][\"V3_0\" + tag]\n            self.v3_A = data[\"KDHartreeFock\"][\"V3_A\" + tag]\n            self.v4_0 = data[\"KDHartreeFock\"][\"V4_0\"]\n\n            # real central form\n            self.rv_0 = data[\"KDHartreeFock\"][\"r_0\"]\n            self.rv_A = data[\"KDHartreeFock\"][\"r_A\"]\n            self.av_0 = data[\"KDHartreeFock\"][\"a_0\"]\n            self.av_A = data[\"KDHartreeFock\"][\"a_A\"]\n\n            # imag volume depth\n            self.w1_0 = data[\"KDImagVolume\"][\"W1_0\" + tag]\n            self.w1_A = data[\"KDImagVolume\"][\"W1_A\" + tag]\n            self.w2_0 = data[\"KDImagVolume\"][\"W2_0\"]\n            self.w2_A = data[\"KDImagVolume\"][\"W2_A\"]\n\n            # imag surface depth\n            self.d1_0 = data[\"KDImagSurface\"][\"D1_0\"]\n            self.d1_asymm = data[\"KDImagSurface\"][\"D1_asymm\"]\n            self.d2_0 = data[\"KDImagSurface\"][\"D2_0\"]\n            self.d2_A = data[\"KDImagSurface\"][\"D2_A\"]\n            self.d2_A2 = data[\"KDImagSurface\"][\"D2_A2\"]\n            self.d2_A3 = data[\"KDImagSurface\"][\"D2_A3\"]\n            self.d3_0 = data[\"KDImagSurface\"][\"D3_0\"]\n\n            # imag surface form\n            self.rd_0 = data[\"KDImagSurface\"][\"r_0\"]\n            self.rd_A = data[\"KDImagSurface\"][\"r_A\"]\n            self.ad_0 = data[\"KDImagSurface\"][\"a_0\" + tag]\n            self.ad_A = data[\"KDImagSurface\"][\"a_A\" + tag]\n\n            # real spin orbit depth\n            self.Vso1_0 = data[\"KDRealSpinOrbit\"][\"V1_0\"]\n            self.Vso1_A = data[\"KDRealSpinOrbit\"][\"V1_A\"]\n            self.Vso2_0 = data[\"KDRealSpinOrbit\"][\"V2_0\"]\n\n            # imag spin orbit form\n            self.Wso1_0 = data[\"KDImagSpinOrbit\"][\"W1_0\"]\n            self.Wso2_0 = data[\"KDImagSpinOrbit\"][\"W2_0\"]\n\n            # spin orbit form\n            self.rso_0 = data[\"KDRealSpinOrbit\"][\"r_0\"]\n            self.rso_A = data[\"KDRealSpinOrbit\"][\"r_A\"]\n            self.aso_0 = data[\"KDRealSpinOrbit\"][\"a_0\"]\n\n            # Coulomb\n            if self.projectile == Projectile.proton:\n                self.rc_0 = data[\"KDCoulomb\"][\"r_C_0\"]\n                self.rc_A = data[\"KDCoulomb\"][\"r_C_A\"]\n                self.rc_A2 = data[\"KDCoulomb\"][\"r_C_A2\"]\n\n        elif \"KDHartreeFock_V1_0\" in data:\n            # real central depth\n            self.v1_0 = data[\"KDHartreeFock_V1_0\"]\n            self.v1_asymm = data[\"KDHartreeFock_V1_asymm\"]\n            self.v1_A = data[\"KDHartreeFock_V1_A\"]\n            self.v2_0 = data[\"KDHartreeFock_V2_0\" + tag]\n            self.v2_A = data[\"KDHartreeFock_V2_A\" + tag]\n            self.v3_0 = data[\"KDHartreeFock_V3_0\" + tag]\n            self.v3_A = data[\"KDHartreeFock_V3_A\" + tag]\n            self.v4_0 = data[\"KDHartreeFock_V4_0\"]\n\n            # real central form\n            self.rv_0 = data[\"KDHartreeFock_r_0\"]\n            self.rv_A = data[\"KDHartreeFock_r_A\"]\n            self.av_0 = data[\"KDHartreeFock_a_0\"]\n            self.av_A = data[\"KDHartreeFock_a_A\"]\n\n            # imag volume depth\n            self.w1_0 = data[\"KDImagVolume_W1_0\" + tag]\n            self.w1_A = data[\"KDImagVolume_W1_A\" + tag]\n            self.w2_0 = data[\"KDImagVolume_W2_0\"]\n            self.w2_A = data[\"KDImagVolume_W2_A\"]\n\n            # imag surface depth\n            self.d1_0 = data[\"KDImagSurface_D1_0\"]\n            self.d1_asymm = data[\"KDImagSurface_D1_asymm\"]\n            self.d2_0 = data[\"KDImagSurface_D2_0\"]\n            self.d2_A = data[\"KDImagSurface_D2_A\"]\n            self.d2_A2 = data[\"KDImagSurface_D2_A2\"]\n            self.d2_A3 = data[\"KDImagSurface_D2_A3\"]\n            self.d3_0 = data[\"KDImagSurface_D3_0\"]\n\n            # imag surface form\n            self.rd_0 = data[\"KDImagSurface_r_0\"]\n            self.rd_A = data[\"KDImagSurface_r_A\"]\n            self.ad_0 = data[\"KDImagSurface_a_0\" + tag]\n            self.ad_A = data[\"KDImagSurface_a_A\" + tag]\n\n            # real spin orbit depth\n            self.Vso1_0 = data[\"KDRealSpinOrbit_V1_0\"]\n            self.Vso1_A = data[\"KDRealSpinOrbit_V1_A\"]\n            self.Vso2_0 = data[\"KDRealSpinOrbit_V2_0\"]\n\n            # imag spin orbit form\n            self.Wso1_0 = data[\"KDImagSpinOrbit_W1_0\"]\n            self.Wso2_0 = data[\"KDImagSpinOrbit_W2_0\"]\n\n            # spin orbit form\n            self.rso_0 = data[\"KDRealSpinOrbit_r_0\"]\n            self.rso_A = data[\"KDRealSpinOrbit_r_A\"]\n            self.aso_0 = data[\"KDRealSpinOrbit_a_0\"]\n\n            # Coulomb\n            if self.projectile == Projectile.proton:\n                self.rc_0 = data[\"KDCoulomb_r_C_0\"]\n                self.rc_A = data[\"KDCoulomb_r_C_A\"]\n                self.rc_A2 = data[\"KDCoulomb_r_C_A2\"]\n        else:\n            raise ValueError(\"Unrecognized parameter file format for KDUQ!\")\n\n        # fermi energy\n        if self.projectile == Projectile.neutron:\n            self.Ef_0 = -11.2814\n            self.Ef_A = 0.02646\n        else:\n            self.Ef_0 = -8.4075\n            self.Ef_A = 0.01378\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.KDGlobal.get_params","title":"<code>get_params(A, Z, mu, E_lab, k)</code>","text":"<p>Calculates Koning-Delaroche global neutron-nucleus OMP parameters for given A, Z, and COM-frame energy, returns params in form useable by EnergizedKoningDelaroche</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>def get_params(self, A, Z, mu, E_lab, k):\n    \"\"\"\n    Calculates Koning-Delaroche global neutron-nucleus OMP parameters for given A, Z,\n    and COM-frame energy, returns params in form useable by EnergizedKoningDelaroche\n    \"\"\"\n\n    N = A - Z\n    delta = (N - Z) / A\n    factor = 1.0\n    if self.projectile == Projectile.proton:\n        delta *= -1.0\n        factor = -1.0\n\n    # fermi energy\n    Ef = self.Ef_0 + self.Ef_A * A\n\n    # real central depth\n    v1 = self.v1_0 - self.v1_asymm * delta - self.v1_A * A\n    v2 = self.v2_0 - self.v2_A * A * factor\n    v3 = self.v3_0 - self.v3_A * A * factor\n    v4 = self.v4_0\n    vv = Vv(E_lab, v1, v2, v3, v4, Ef)\n\n    # real central form\n    rv = self.rv_0 - self.rv_A * A ** (-1.0 / 3.0)\n    av = self.av_0 - self.av_A * A\n\n    # imag volume depth\n    w1 = self.w1_0 + self.w1_A * A\n    w2 = self.w2_0 + self.w2_A * A\n    wv = Wv(E_lab, w1, w2, Ef)\n\n    # imag volume form\n    rwv = rv\n    awv = av\n\n    # imag surface depth\n    d1 = self.d1_0 - self.d1_asymm * delta\n    d2 = self.d2_0 + self.d2_A / (1 + np.exp((A - self.d2_A3) / self.d2_A2))\n    d3 = self.d3_0\n    wd = Wd(E_lab, d1, d2, d3, Ef)\n\n    # imag surface form\n    rd = self.rd_0 - self.rd_A * A ** (1.0 / 3.0)\n    ad = self.ad_0 - self.ad_A * A * factor\n\n    # real spin orbit depth\n    vso1 = self.Vso1_0 + self.Vso1_A * A\n    vso2 = self.Vso2_0\n    vso = Vso(E_lab, vso1, vso2, Ef)\n\n    # real spin orbit form\n    rso = self.rso_0 - self.rso_A * A ** (-1.0 / 3.0)\n    aso = self.aso_0\n\n    # imag spin orbit form\n    wso1 = self.Wso1_0\n    wso2 = self.Wso2_0\n    wso = Wso(E_lab, wso1, wso2, Ef)\n\n    # imag spin orbit form\n    rwso = rso\n    awso = aso\n\n    # Coulomb radius\n    R_C = 0\n    if self.projectile == Projectile.proton:\n        # Coulomb radius\n        rc0 = (\n            self.rc_0\n            + self.rc_A * A ** (-2.0 / 3.0)\n            + self.rc_A2 * A ** (-5.0 / 3.0)\n        )\n        R_C = rc0 * A ** (1.0 / 3.0)\n\n        # Coulomb correction\n        Vcbar = 1.73 / rc0 * Z * A ** (-1.0 / 3.0)\n        Vc = delta_VC(E_lab, Vcbar, v1, v2, v3, v4, Ef)\n        vv += Vc\n\n    # 15 params total\n    params = np.array(\n        [\n            vv,\n            rv * A ** (1.0 / 3.0),\n            av,\n            wv,\n            rwv * A ** (1.0 / 3.0),\n            awv,\n            wd,\n            rd * A ** (1.0 / 3.0),\n            ad,\n            vso,\n            rso * A ** (1.0 / 3.0),\n            aso,\n            wso,\n            rwso * A ** (1.0 / 3.0),\n            awso,\n        ]\n    )\n\n    return R_C, params\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.KoningDelaroche","title":"<code>KoningDelaroche(energy, training_info, mu, l_max=20, n_basis=8, explicit_training=False, n_train=1000, rho_mesh=DEFAULT_RHO_MESH, match_points=None, method='collocation', **kwargs)</code>","text":"<p>               Bases: <code>InteractionEIMSpace</code></p> <p>Koning-Delaroche potential (without energy-dependent strength coefficients) for arbitrary systems defined by <code>mu</code>, <code>energy</code>, <code>ell</code>, <code>Z_1</code>, and <code>Z_2</code>.</p> <p>Wraps the Koning-Delaroche potential into a <code>rose</code>-friendly class. Saves system-specific information.</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>float</code> <p>reduced mass of the 2-body system</p> required <code>ell</code> <code>int</code> <p>angular momentum</p> required <code>energy</code> <code>float</code> <p>center-of-mass, scattering energy</p> required <code>training_info</code> <code>ndarray</code> <p>either (1) parameters bounds or (2) explicit training points</p> <p>If (1): This is a 2-column matrix. The first column are the lower bounds. The second are the upper bounds. Each row maps to a single parameter.</p> <p>If (2): This is an MxN matrix. N is the number of parameters. M is the number of samples.</p> required <code>n_basis</code> <code>int</code> <p>number of basis states to use for EIM</p> <code>8</code> <code>explicit_training</code> <code>bool</code> <p>True implies training_info case (2); False implies (1)</p> <code>False</code> <code>n_train</code> <code>int</code> <p>how many training samples to use</p> <code>1000</code> <code>rho_mesh</code> <code>ndarray</code> <p>$\\rho$ (or $s$) grid values</p> <code>DEFAULT_RHO_MESH</code> <code>match_points</code> <code>ndarray</code> <p>$\\rho$ points at which we demand the EIMed potential match the true potential</p> <code>None</code> <p>Returns:</p> Name Type Description <code>instance</code> <code>KoningDelaroche</code> <p>instance of the class</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>def __init__(\n    self,\n    energy: float,\n    training_info: np.array,\n    mu: float,\n    l_max=20,\n    n_basis: int = 8,\n    explicit_training: bool = False,\n    n_train: int = 1000,\n    rho_mesh: np.array = DEFAULT_RHO_MESH,\n    match_points: np.array = None,\n    method=\"collocation\",\n    **kwargs,\n):\n    r\"\"\"Wraps the Koning-Delaroche potential into a `rose`-friendly class.\n    Saves system-specific information.\n\n    Parameters:\n        mu (float): reduced mass of the 2-body system\n        ell (int): angular momentum\n        energy (float): center-of-mass, scattering energy\n        training_info (ndarray): either (1) parameters bounds or (2) explicit training points\n\n            If (1):\n            This is a 2-column matrix. The first column are the lower\n            bounds. The second are the upper bounds. Each row maps to a\n            single parameter.\n\n            If (2):\n            This is an MxN matrix. N is the number of parameters. M is the\n            number of samples.\n        n_basis (int): number of basis states to use for EIM\n        explicit_training (bool): True implies training_info case (2); False implies (1)\n        n_train (int): how many training samples to use\n        rho_mesh (ndarray):  $\\rho$ (or $s$) grid values\n        match_points (ndarray): $\\rho$ points at which we demand the EIMed\n            potential match the true potential\n\n    Returns:\n        instance (KoningDelaroche): instance of the class\n\n    \"\"\"\n    super().__init__(\n        coordinate_space_potential=KD_simple,\n        n_theta=NUM_PARAMS,\n        mu=mu,\n        energy=energy,\n        training_info=training_info,\n        Z_1=0,\n        Z_2=0,\n        is_complex=True,\n        spin_orbit_term=KD_simple_so,\n        n_basis=n_basis,\n        explicit_training=explicit_training,\n        n_train=n_train,\n        rho_mesh=rho_mesh,\n        match_points=match_points,\n        method=method,\n        l_max=l_max,\n        **kwargs,\n    )\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.KD","title":"<code>KD(r, E, v1, v2, v3, v4, w1, w2, d1, d2, d3, Ef, Rv, av, Rd, ad)</code>","text":"<p>Koning-Delaroche without the spin-orbit terms - Eq. (1)</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>@njit\ndef KD(r, E, v1, v2, v3, v4, w1, w2, d1, d2, d3, Ef, Rv, av, Rd, ad):\n    \"\"\"Koning-Delaroche without the spin-orbit terms - Eq. (1)\"\"\"\n    return (\n        -Vv(E, v1, v2, v3, v4, Ef) * woods_saxon_safe(r, Rv, av)\n        - 1j * Wv(E, w1, w2, Ef) * woods_saxon_safe(r, Rv, av)\n        - 1j * (-4 * ad) * Wd(E, d1, d2, d3, Ef) * woods_saxon_prime_safe(r, Rd, ad)\n    )\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.KD_simple","title":"<code>KD_simple(r, alpha)</code>","text":"<p>simplified Koning-Delaroche without the spin-orbit terms</p> <p>Take Eq. (1) and remove the energy dependence of the coefficients.</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>@njit\ndef KD_simple(r, alpha):\n    r\"\"\"simplified Koning-Delaroche without the spin-orbit terms\n\n    Take Eq. (1) and remove the energy dependence of the coefficients.\n    \"\"\"\n    vv, rv, av, wv, rwv, awv, wd, rd, ad = decompose_alpha(alpha)[0]\n    return (\n        -vv * woods_saxon_safe(r, rv, av)\n        - 1j * wv * woods_saxon_safe(r, rwv, awv)\n        - 1j * (-4 * ad) * wd * woods_saxon_prime_safe(r, rd, ad)\n    )\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.KD_simple_so","title":"<code>KD_simple_so(r, alpha, lds)</code>","text":"<p>simplified Koning-Delaroche spin-orbit terms</p> <p>Take Eq. (1) and remove the energy dependence of the coefficients.</p> <p>lds: l \u2022 s = 1/2 * (j(j+1) - l(l+1) - s(s+1))</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>@njit\ndef KD_simple_so(r, alpha, lds):\n    r\"\"\"simplified Koning-Delaroche spin-orbit terms\n\n    Take Eq. (1) and remove the energy dependence of the coefficients.\n\n    lds: l \u2022 s = 1/2 * (j(j+1) - l(l+1) - s(s+1))\n    \"\"\"\n    vso, rso, aso, wso, rwso, awso = decompose_alpha(alpha)[1]\n    return lds * (\n        vso / MASS_PION**2 * thomas_safe(r, rso, aso)\n        + 1j * wso / MASS_PION**2 * thomas_safe(r, rwso, awso)\n    )\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.Vso","title":"<code>Vso(E, vso1, vso2, Ef)</code>","text":"<p>energy-dependent, spin-orbit strength --- real term, Eq. (7)</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>@njit\ndef Vso(E, vso1, vso2, Ef):\n    \"\"\"energy-dependent, spin-orbit strength --- real term, Eq. (7)\"\"\"\n    return vso1 * np.exp(-vso2 * (E - Ef))\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.Vv","title":"<code>Vv(E, v1, v2, v3, v4, Ef)</code>","text":"<p>energy-dependent, volume-central strength - real term, Eq. (7)</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>@njit\ndef Vv(E, v1, v2, v3, v4, Ef):\n    r\"\"\"energy-dependent, volume-central strength - real term, Eq. (7)\"\"\"\n    return v1 * (1 - v2 * (E - Ef) + v3 * (E - Ef) ** 2 - v4 * (E - Ef) ** 3)\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.Wd","title":"<code>Wd(E, d1, d2, d3, Ef)</code>","text":"<p>energy-dependent, surface-central strength - imaginary term (no real term), Eq. (7)</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>@njit\ndef Wd(E, d1, d2, d3, Ef):\n    \"\"\"energy-dependent, surface-central strength - imaginary term (no real\n    term), Eq. (7)\n    \"\"\"\n    return d1 * (E - Ef) ** 2 / ((E - Ef) ** 2 + d3**2) * np.exp(-d2 * (E - Ef))\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.Wso","title":"<code>Wso(E, wso1, wso2, Ef)</code>","text":"<p>energy-dependent, spin-orbit strength --- imaginary term, Eq. (7)</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>@njit\ndef Wso(E, wso1, wso2, Ef):\n    \"\"\"energy-dependent, spin-orbit strength --- imaginary term, Eq. (7)\"\"\"\n    return wso1 * (E - Ef) ** 2 / ((E - Ef) ** 2 + wso2**2)\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.Wv","title":"<code>Wv(E, w1, w2, Ef)</code>","text":"<p>energy-dependent, volume-central strength - imaginary term, Eq. (7)</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>@njit\ndef Wv(E, w1, w2, Ef):\n    \"\"\"energy-dependent, volume-central strength - imaginary term, Eq. (7)\"\"\"\n    return w1 * (E - Ef) ** 2 / ((E - Ef) ** 2 + w2**2)\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.decompose_alpha","title":"<code>decompose_alpha(alpha)</code>","text":"<p>Splits the parameter-space vector into non-spin-orbit and spin-orbit parameters.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>interaction parameters</p> required <p>Returns:</p> Name Type Description <code>parameters</code> <code>tuple</code> <p>2-tuple of non-spin-orbit (<code>parameters[0]</code>) and spin-orbit parameters (<code>parameters[1]</code>)</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>@njit\ndef decompose_alpha(alpha):\n    r\"\"\"Splits the parameter-space vector into non-spin-orbit and spin-orbit\n    parameters.\n\n    Parameters:\n        alpha (ndarray): interaction parameters\n\n    Returns:\n        parameters (tuple): 2-tuple of non-spin-orbit (`parameters[0]`) and\n            spin-orbit parameters (`parameters[1]`)\n\n    \"\"\"\n    vv, rv, av, wv, rwv, awv, wd, rd, ad, vso, rso, aso, wso, rwso, awso = alpha\n    return (vv, rv, av, wv, rwv, awv, wd, rd, ad), (vso, rso, aso, wso, rwso, awso)\n</code></pre>"},{"location":"interaction/#rose.koning_delaroche.delta_VC","title":"<code>delta_VC(E, Vcbar, v1, v2, v3, v4, Ef)</code>","text":"<p>energy dependent Coulomb correction term, Eq. 23</p> Source code in <code>src/rose/koning_delaroche.py</code> <pre><code>@njit\ndef delta_VC(E, Vcbar, v1, v2, v3, v4, Ef):\n    \"\"\"energy dependent Coulomb correction term, Eq. 23\"\"\"\n    return v1 * Vcbar * (v2 - 2 * v3 * (E - Ef) + 3 * v4 * (E - Ef) ** 2)\n</code></pre>"},{"location":"rbe/","title":"Reduced-Basis Emulator","text":"<p>A ReducedBasisEmulator builds the reduced basis for a given interaction and partial wave.</p> <p>It instantiates a Basis and precomputes the integrals it can with the basis states and operators. When the user asks for an emulated phase shift, the emulator computes the $\\hat{\\phi}$ coefficients.</p>"},{"location":"rbe/#rose.reduced_basis_emulator.ReducedBasisEmulator","title":"<code>ReducedBasisEmulator(interaction, basis, s_0=6 * np.pi, initialize_emulator=True)</code>","text":"<p>A ReducedBasisEmulator (RBE) uses the specified <code>interaction</code> and <code>theta_train</code> to generate solutions to the Schr\u00f6dinger equation at a specific energy (<code>energy</code>) and partial wave (<code>l</code>).</p> <p>Using the Galerkin projection method, a linear combination of those solutions (or a PCA basis of them) is found at some arbitrary point in parameter space, <code>theta</code>.</p> <p>Trains a reduced-basis emulator based on the provided interaction and basis.</p> <p>Parameters:</p> Name Type Description Default <code>interaction</code> <code>Interaction</code> <p>local interaction</p> required <code>basis</code> <code>Basis</code> <p>see Basis documentation</p> required <code>s_0</code> <code>float</code> <p>$s$ point where the phase shift is extracted</p> <code>6 * pi</code> <code>initialize_emulator </code> <p>whether to construct matrix elements for emulation now, or leave them for later. Initialization is required for emulation of phase shifts or wavefunctions, but not for the exact phase shifts. This argument is typically always true, unless no emulation is desired (e.g. in ScatteringAmplitudeEmulator.HIFI_solver)</p> required <p>Returns:</p> Name Type Description <code>rbe</code> <code>ReducedBasisEmulator</code> <p>$\\ell$-specific, reduced basis emulator</p> Source code in <code>src/rose/reduced_basis_emulator.py</code> <pre><code>def __init__(\n    self,\n    interaction: Interaction,\n    basis: Basis,\n    s_0: float = 6 * np.pi,\n    initialize_emulator=True,\n):\n    r\"\"\"Trains a reduced-basis emulator based on the provided interaction and basis.\n\n    Parameters:\n        interaction (Interaction): local interaction\n        basis (Basis): see [Basis documentation](basis.md)\n        s_0 (float): $s$ point where the phase shift is extracted\n        initialize_emulator : whether to construct matrix elements for emulation now, or\n            leave them for later. Initialization is required for emulation of phase shifts or\n            wavefunctions, but not for the exact phase shifts. This argument is typically\n            always true, unless no emulation is desired (e.g. in\n            ScatteringAmplitudeEmulator.HIFI_solver)\n\n    Returns:\n        rbe (ReducedBasisEmulator): $\\ell$-specific, reduced basis emulator\n\n    \"\"\"\n    self.interaction = interaction\n    self.basis = basis\n    self.l = self.basis.l\n\n    if isinstance(self.basis, CustomBasis):\n        self.basis.solver = basis.solver\n\n    self.s_mesh = np.copy(basis.rho_mesh)\n    self.s_0 = s_0\n\n    if initialize_emulator:\n        self.initialize_emulator()\n</code></pre>"},{"location":"rbe/#rose.reduced_basis_emulator.ReducedBasisEmulator.coefficients","title":"<code>coefficients(theta)</code>","text":"<p>Calculated the coefficients in the $\\hat{\\phi}$ expansion.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>ndarray</code> <p>point in parameters space</p> required <p>Returns:</p> Name Type Description <code>coefficients</code> <code>ndarray</code> <p>coefficients in $\\hat{\\phi}$ expansion</p> Source code in <code>src/rose/reduced_basis_emulator.py</code> <pre><code>def coefficients(self, theta: np.array):\n    r\"\"\"Calculated the coefficients in the $\\hat{\\phi}$ expansion.\n\n    Parameters:\n        theta (ndarray): point in parameters space\n\n    Returns:\n        coefficients (ndarray): coefficients in $\\hat{\\phi}$ expansion\n\n    \"\"\"\n    invk, beta = self.interaction.coefficients(theta)\n\n    A_utilde = np.einsum(\"i,ijk\", beta, self.A_2)\n    A = self.A_13 + A_utilde + invk * self.A_3_coulomb\n\n    b_utilde = beta @ self.b_2\n    b = self.b_13 + b_utilde + invk * self.b_3_coulomb\n\n    return np.linalg.solve(A, b)\n</code></pre>"},{"location":"rbe/#rose.reduced_basis_emulator.ReducedBasisEmulator.emulate_phase_shift","title":"<code>emulate_phase_shift(theta)</code>","text":"<p>Calculate the emulated phase shift.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>ndarray</code> <p>point in parameters space</p> required <p>Returns:</p> Name Type Description <code>delta</code> <code>float | complex</code> <p>emulated phase shift (extracted at $s_0$)</p> Source code in <code>src/rose/reduced_basis_emulator.py</code> <pre><code>def emulate_phase_shift(self, theta: np.array):\n    r\"\"\"Calculate the emulated phase shift.\n\n    Parameters:\n        theta (ndarray): point in parameters space\n\n    Returns:\n        delta (float | complex): emulated phase shift (extracted at $s_0$)\n\n    \"\"\"\n    return np.log(self.S_matrix_element(theta)) / 2j\n</code></pre>"},{"location":"rbe/#rose.reduced_basis_emulator.ReducedBasisEmulator.emulate_wave_function","title":"<code>emulate_wave_function(theta)</code>","text":"<p>Calculate the emulated wave function.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>ndarray</code> <p>point in parameters space</p> required <p>Returns:</p> Name Type Description <code>wave_function</code> <code>ndarray</code> <p>$\\hat{\\phi}$ on the default $s$ mesh</p> Source code in <code>src/rose/reduced_basis_emulator.py</code> <pre><code>def emulate_wave_function(self, theta: np.array):\n    r\"\"\"Calculate the emulated wave function.\n\n    Parameters:\n        theta (ndarray): point in parameters space\n\n    Returns:\n        wave_function (ndarray): $\\hat{\\phi}$ on the default $s$ mesh\n\n    \"\"\"\n    x = self.coefficients(theta)\n    return self.basis.phi_hat(x)\n</code></pre>"},{"location":"rbe/#rose.reduced_basis_emulator.ReducedBasisEmulator.from_train","title":"<code>from_train(interaction, theta_train, n_basis=4, use_svd=True, s_mesh=DEFAULT_RHO_MESH, s_0=6 * np.pi, base_solver=SchroedingerEquation(None))</code>  <code>classmethod</code>","text":"<p>Trains a reduced-basis emulator based on the provided interaction and training space.</p> <p>Parameters:</p> Name Type Description Default <code>interaction</code> <code>Interaction</code> <p>local interaction</p> required <code>theta_train</code> <code>ndarray</code> <p>training points in parameter space; shape = (n_points, n_parameters)</p> required <code>n_basis</code> <code>int</code> <p>number of basis vectors for $\\hat{\\phi}$ expansion</p> <code>4</code> <code>use_svd</code> <code>bool</code> <p>Use principal components of training wave functions?</p> <code>True</code> <code>s_mesh</code> <code>ndarray</code> <p>$s$ (or $\\rho$) grid on which wave functions are evaluated</p> <code>DEFAULT_RHO_MESH</code> <code>s_0</code> <code>float</code> <p>$s$ point where the phase shift is extracted</p> <code>6 * pi</code> <code>base_solver </code> <p>the solver used in the basis.</p> required <p>Returns:</p> Name Type Description <code>rbe</code> <code>ReducedBasisEmulator</code> <p>$\\ell$-specific, reduced basis emulator</p> Source code in <code>src/rose/reduced_basis_emulator.py</code> <pre><code>@classmethod\ndef from_train(\n    cls,\n    interaction: Interaction,\n    theta_train: np.array,\n    n_basis: int = 4,\n    use_svd: bool = True,\n    s_mesh: np.array = DEFAULT_RHO_MESH,\n    s_0: float = 6 * np.pi,\n    base_solver: SchroedingerEquation = SchroedingerEquation(None),\n):\n    r\"\"\"Trains a reduced-basis emulator based on the provided interaction and training space.\n\n    Parameters:\n        interaction (Interaction): local interaction\n        theta_train (ndarray): training points in parameter space;\n            shape = (n_points, n_parameters)\n        n_basis (int): number of basis vectors for $\\hat{\\phi}$ expansion\n        use_svd (bool): Use principal components of training wave functions?\n        s_mesh (ndarray): $s$ (or $\\rho$) grid on which wave functions are evaluated\n        s_0 (float): $s$ point where the phase shift is extracted\n        base_solver : the solver used in the basis.\n\n    Returns:\n        rbe (ReducedBasisEmulator): $\\ell$-specific, reduced basis emulator\n\n    \"\"\"\n\n    basis = RelativeBasis(\n        base_solver.clone_for_new_interaction(interaction),\n        theta_train,\n        s_mesh,\n        n_basis,\n        interaction.ell,\n        use_svd,\n    )\n    return cls(interaction, basis, s_0=s_0)\n</code></pre>"},{"location":"rbe/#rose.reduced_basis_emulator.ReducedBasisEmulator.load","title":"<code>load(obj, filename)</code>  <code>classmethod</code>","text":"<p>Loads a previously trained emulator.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>string</code> <p>name of file</p> required <p>Returns:</p> Name Type Description <code>emulator</code> <code>ReducedBasisEmulator</code> <p>previously trainined <code>ReducedBasisEmulator</code></p> Source code in <code>src/rose/reduced_basis_emulator.py</code> <pre><code>@classmethod\ndef load(obj, filename):\n    r\"\"\"Loads a previously trained emulator.\n\n    Parameters:\n        filename (string): name of file\n\n    Returns:\n        emulator (ReducedBasisEmulator): previously trainined `ReducedBasisEmulator`\n\n    \"\"\"\n    with open(filename, \"rb\") as f:\n        rbe = pickle.load(f)\n    return rbe\n</code></pre>"},{"location":"rbe/#rose.reduced_basis_emulator.ReducedBasisEmulator.save","title":"<code>save(filename)</code>","text":"<p>Write the current emulator to file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>string</code> <p>name of the file where the emulator is saved</p> required <p>Returns:</p> Name Type Description <code>_</code> <code>None</code> <p>nothing</p> Source code in <code>src/rose/reduced_basis_emulator.py</code> <pre><code>def save(self, filename):\n    r\"\"\"Write the current emulator to file.\n\n    Parameters:\n        filename (string): name of the file where the emulator is saved\n\n    Returns:\n        _ (None): nothing\n    \"\"\"\n    with open(filename, \"wb\") as f:\n        pickle.dump(self, f)\n</code></pre>"},{"location":"sae/","title":"Scattering Amplitude Emulator","text":"<p>The Scattering Amplitude Emulator (SAE) is the primary user-facing class. Minimally, all the user should have to do is (1) pick an Interaction, (2) choose a set of parameter-space, training points, and (3) pick an $\\ell_\\max$. That's it. There is no step... well, there's no step 4 at least.</p>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator","title":"<code>ScatteringAmplitudeEmulator(interaction_space, bases, l_max=None, angles=DEFAULT_ANGLE_MESH, s_0=6 * np.pi, verbose=True, Smatrix_abs_tol=1e-06, initialize_emulator=True)</code>","text":"<p>Trains a reduced-basis emulator that computes differential and total cross sections     (from emulated phase shifts).</p> <p>Parameters:</p> Name Type Description Default <code>interaction_space</code> <code>InteractionSpace</code> <p>local interaction up to (and including $\\ell_\\max$)</p> required <code>bases</code> <code>list[Basis]</code> <p>list of <code>Basis</code> objects</p> required <code>l_max</code> <code>int</code> <p>maximum angular momentum to include in the sum approximating the cross section</p> <code>None</code> <code>angles</code> <code>ndarray</code> <p>Differential cross sections are functions of the angles. These are the specific values at which the user wants to emulate the cross section.</p> <code>DEFAULT_ANGLE_MESH</code> <code>s_0</code> <code>float</code> <p>$s$ point where the phase shift is extracted</p> <code>6 * pi</code> <code>verbose</code> <code>bool</code> <p>Do you want the class to print out warnings?</p> <code>True</code> <code>Smatrix_abs_tol </code> <p>absolute tolerance for deviation of real part of S-matrix amplitudes from 1, used as criteria to stop calculation ig higher partial waves are negligble</p> required <code>initialize_emulator </code> <p>build the low-order emulator (True required for emulation)</p> required <p>Attributes:</p> Name Type Description <code>l_max</code> <code>int</code> <p>maximum angular momentum</p> <code>angles</code> <code>ndarray</code> <p>angle values at which the differential cross section is desired</p> <code>rbes</code> <code>list</code> <p>list of <code>ReducedBasisEmulators</code>; one for each partial wave (and total $j$ with spin-orbit)</p> <code>ls</code> <code>ndarray</code> <p>angular momenta; shape = (<code>l_max</code>+1, 1)</p> <code>P_l_costheta</code> <code>ndarray</code> <p>Legendre polynomials evaluated at <code>angles</code></p> <code>P_1_l_costheta</code> <code>ndarray</code> <p>associated Legendre polynomials evalated at <code>angles</code></p> <code>k_c</code> <code>float</code> <p>Coulomb momentum, $k\\eta$</p> <code>eta</code> <code>float</code> <p>Sommerfeld parameter</p> <code>sigma_l</code> <code>float</code> <p>Coulomb phase shift</p> <code>f_c</code> <code>ndarray</code> <p>scattering amplitude</p> <code>rutherford</code> <code>ndarray</code> <p>Rutherford scattering</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def __init__(\n    self,\n    interaction_space: InteractionSpace,\n    bases: list,\n    l_max: int = None,\n    angles: np.array = DEFAULT_ANGLE_MESH,\n    s_0: float = 6 * np.pi,\n    verbose: bool = True,\n    Smatrix_abs_tol=1.0e-6,\n    initialize_emulator=True,\n):\n    r\"\"\"Trains a reduced-basis emulator that computes differential and total cross sections\n        (from emulated phase shifts).\n\n    Parameters:\n        interaction_space (InteractionSpace): local interaction up to (and including $\\ell_\\max$)\n        bases (list[Basis]): list of `Basis` objects\n        l_max (int): maximum angular momentum to include in the sum approximating the cross section\n        angles (ndarray): Differential cross sections are functions of the\n            angles. These are the specific values at which the user wants to\n            emulate the cross section.\n        s_0 (float): $s$ point where the phase shift is extracted\n        verbose (bool): Do you want the class to print out warnings?\n        Smatrix_abs_tol : absolute tolerance for deviation of real part of S-matrix amplitudes\n            from 1, used as criteria to stop calculation ig higher partial waves are negligble\n        initialize_emulator : build the low-order emulator (True required for emulation)\n\n    Attributes:\n        l_max (int): maximum angular momentum\n        angles (ndarray): angle values at which the differential cross section is desired\n        rbes (list): list of `ReducedBasisEmulators`; one for each partial wave\n            (and total $j$ with spin-orbit)\n        ls (ndarray): angular momenta; shape = (`l_max`+1, 1)\n        P_l_costheta (ndarray): Legendre polynomials evaluated at `angles`\n        P_1_l_costheta (ndarray): **associated** Legendre polynomials evalated at `angles`\n        k_c (float): Coulomb momentum, $k\\eta$\n        eta (float): Sommerfeld parameter\n        sigma_l (float): Coulomb phase shift\n        f_c (ndarray): scattering amplitude\n        rutherford (ndarray): Rutherford scattering\n\n    \"\"\"\n    # partial waves\n    if l_max is None:\n        l_max = interaction_space.l_max\n    self.l_max = l_max\n    self.Smatrix_abs_tol = Smatrix_abs_tol\n\n    # construct bases\n    self.rbes = []\n    for interaction_list, basis_list in zip(interaction_space.interactions, bases):\n        self.rbes.append(\n            [\n                ReducedBasisEmulator(\n                    interaction,\n                    basis,\n                    s_0=s_0,\n                    initialize_emulator=initialize_emulator,\n                )\n                for (interaction, basis) in zip(interaction_list, basis_list)\n            ]\n        )\n\n    # Let's precompute the things we can.\n    self.angles = angles.copy()\n    self.ls = np.arange(self.l_max + 1)[:, np.newaxis]\n    self.P_l_costheta = eval_legendre(self.ls, np.cos(self.angles))\n    self.P_1_l_costheta = lpmv(1, self.ls, np.cos(self.angles))\n\n    # Coulomb scattering amplitude\n    if (\n        self.rbes[0][0].interaction.k is not None\n        and self.rbes[0][0].interaction.k_c &gt; 0\n    ):\n        k = self.rbes[0][0].interaction.k\n        self.k_c = self.rbes[0][0].interaction.k_c\n        self.eta = self.k_c / k\n        self.sigma_l = np.angle(gamma(1 + self.ls + 1j * self.eta))\n        sin2 = np.sin(self.angles / 2) ** 2\n        self.f_c = (\n            -self.eta\n            / (2 * k * sin2)\n            * np.exp(\n                2j * self.sigma_l[0]\n                - 2j * self.eta * np.log(np.sin(self.angles / 2))\n            )\n        )\n        self.rutherford = (\n            10 * self.eta**2 / (4 * k**2 * np.sin(self.angles / 2) ** 4)\n        )\n    else:\n        self.sigma_l = np.angle(gamma(1 + self.ls + 1j * 0))\n        self.k_c = 0\n        self.eta = 0\n        self.f_c = 0.0 * np.exp(2j * self.sigma_l[0])\n        self.rutherford = 0.0 / (np.sin(self.angles / 2) ** 4)\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.HIFI_solver","title":"<code>HIFI_solver(interaction_space, base_solver=None, l_max=None, angles=DEFAULT_ANGLE_MESH, verbose=True, Smatrix_abs_tol=1e-06, s_mesh=None)</code>  <code>classmethod</code>","text":"<p>Sets up a ScatteringAmplitudeEmulator without any emulation capabilities, for use purely     as a high-fidelity solver, for which the exact_* functions will be used.</p> <p>Parameters:</p> Name Type Description Default <code>interaction_space</code> <code>InteractionSpace</code> <p>local interaction up to (and including $\\ell_\\max$)</p> required <code>base_solver </code> <p>the solver used. Must be an instance of SchroedingerEquation or a derived class of it. The solvers for each <code>interaction</code> in <code>interaction_space</code> will be constructed using <code>base_solver.clone_for_new_interaction</code>. Defaults to the base class using Runge-Kutta; <code>SchroedingerEquation</code></p> required <code>l_max</code> <code>int</code> <p>maximum angular momentum to include in the sum approximating the cross section</p> <code>None</code> <code>angles</code> <code>ndarray</code> <p>Differential cross sections are functions of the angles. These are the specific values at which the user wants to emulate the cross section.</p> <code>DEFAULT_ANGLE_MESH</code> <code>s_0</code> <code>float</code> <p>$s$ point where the phase shift is extracted</p> required <code>verbose</code> <code>bool</code> <p>Do you want the class to print out warnings?</p> <code>True</code> <code>Smatrix_abs_tol </code> <p>absolute tolerance for deviation of real part of S-matrix amplitudes from 1, used as criteria to stop calculation ig higher partial waves are negligble</p> required <code>s_mesh</code> <code>ndarray</code> <p>$s$ (or $\\rho$) grid on which wave functions are evaluated</p> <code>None</code> <p>Returns:</p> Name Type Description <code>sae</code> <code>ScatteringAmplitudeEmulator</code> <p>scattering amplitude emulator</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>@classmethod\ndef HIFI_solver(\n    cls,\n    interaction_space: InteractionSpace,\n    base_solver: SchroedingerEquation = None,\n    l_max: int = None,\n    angles: np.array = DEFAULT_ANGLE_MESH,\n    verbose: bool = True,\n    Smatrix_abs_tol: float = 1.0e-6,\n    s_mesh=None,\n):\n    r\"\"\"Sets up a ScatteringAmplitudeEmulator without any emulation capabilities, for use purely\n        as a high-fidelity solver, for which the exact_* functions will be used.\n\n    Parameters:\n        interaction_space (InteractionSpace): local interaction up to (and including $\\ell_\\max$)\n        base_solver : the solver used. Must be an instance of SchroedingerEquation or a derived\n            class of it. The solvers for each `interaction` in `interaction_space` will be\n            constructed using `base_solver.clone_for_new_interaction`. Defaults to the base class\n            using Runge-Kutta; `SchroedingerEquation`\n        l_max (int): maximum angular momentum to include in the sum approximating the cross section\n        angles (ndarray): Differential cross sections are functions of the\n            angles. These are the specific values at which the user wants to\n            emulate the cross section.\n        s_0 (float): $s$ point where the phase shift is extracted\n        verbose (bool): Do you want the class to print out warnings?\n        Smatrix_abs_tol : absolute tolerance for deviation of real part of S-matrix amplitudes\n            from 1, used as criteria to stop calculation ig higher partial waves are negligble\n        s_mesh (ndarray): $s$ (or $\\rho$) grid on which wave functions are evaluated\n\n    Returns:\n        sae (ScatteringAmplitudeEmulator): scattering amplitude emulator\n\n    \"\"\"\n    if base_solver is None:\n        base_solver = SchroedingerEquation.make_base_solver()\n\n    if s_mesh is None:\n        s_mesh = np.linspace(\n            base_solver.domain[0],\n            base_solver.domain[1],\n            SchroedingerEquation.DEFAULT_NUM_PTS,\n        )\n\n    assert (\n        s_mesh[0] &gt;= base_solver.domain[0] and s_mesh[-1] &lt;= base_solver.domain[1]\n    )\n\n    bases = []\n    for interaction_list in interaction_space.interactions:\n        basis_list = []\n        for interaction in interaction_list:\n            solver = base_solver.clone_for_new_interaction(interaction)\n            basis = Basis(solver, None, s_mesh, None)\n            basis_list.append(basis)\n        bases.append(basis_list)\n\n    return cls(\n        interaction_space,\n        bases,\n        l_max,\n        angles,\n        s_0=base_solver.s_0,\n        verbose=verbose,\n        Smatrix_abs_tol=Smatrix_abs_tol,\n        initialize_emulator=False,\n    )\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.calculate_xs","title":"<code>calculate_xs(Splus, Sminus, alpha, angles=None)</code>","text":"<p>Calculates the: - differential cross section in mb/Sr (as a ratio to a Rutherford xs if provided) - analyzing power - total and reacion cross sections in mb</p> Paramaters <p>Splus (ndarray) : spin-up phase shifs Sminus (ndarray) : spin-down phase shifts alpha (ndarray) : interaction parameters angles (ndarray) : (optional), angular grid on which to evaluate analyzing \\ powers and differential cross section</p> Returns <p>cross sections (NucleonNucleusXS) :</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def calculate_xs(\n    self,\n    Splus: np.array,\n    Sminus: np.array,\n    alpha: np.array,\n    angles: np.array = None,\n):\n    r\"\"\"Calculates the:\n        - differential cross section in mb/Sr (as a ratio to a Rutherford xs if provided)\n        - analyzing power\n        - total and reacion cross sections in mb\n\n        Paramaters:\n            Splus (ndarray) : spin-up phase shifs\n            Sminus (ndarray) : spin-down phase shifts\n            alpha (ndarray) : interaction parameters\n            angles (ndarray) : (optional), angular grid on which to evaluate analyzing \\\n            powers and differential cross section\n\n        Returns :\n            cross sections (NucleonNucleusXS) :\n    \"\"\"\n    k = self.rbes[0][0].interaction.momentum(alpha)\n\n    # determine desired angle grid and precompute\n    # Legendre functions if necessary\n    if angles is None:\n        angles = self.angles\n        P_l_costheta = self.P_l_costheta\n        P_1_l_costheta = self.P_1_l_costheta\n        rutherford = self.rutherford\n        f_c = self.f_c\n    else:\n        assert np.max(angles) &lt;= np.pi and np.min(angles) &gt;= 0\n        P_l_costheta = eval_legendre(self.ls, np.cos(angles))\n        P_1_l_costheta = lpmv(1, self.ls, np.cos(angles))\n\n        sin2 = np.sin(angles / 2) ** 2\n        rutherford = 10 * self.eta**2 / (4 * k**2 * sin2**2)\n        f_c = (\n            -self.eta\n            / (2 * k * sin2)\n            * np.exp(-1j * self.eta * np.log(sin2) + 2j * self.sigma_l[0])\n        )\n\n    if self.rbes[0][0].interaction.eta(alpha) &gt; 0:\n        return NucleonNucleusXS(\n            *xs_calc_coulomb(\n                k,\n                angles,\n                Splus,\n                Sminus,\n                P_l_costheta,\n                P_1_l_costheta,\n                f_c,\n                self.sigma_l,\n                rutherford,\n            )\n        )\n    else:\n        return NucleonNucleusXS(\n            *xs_calc_neutral(\n                k,\n                angles,\n                Splus,\n                Sminus,\n                P_l_costheta,\n                P_1_l_costheta,\n            )\n        )\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.dsdo","title":"<code>dsdo(alpha, Splus, Sminus)</code>","text":"<p>Gives the differential cross section (dsigma/dOmega = dsdo) in mb/Sr.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter-space vector</p> required <code>Splus</code> <code>ndarray</code> <p>spin-up smatrix elements</p> required <code>Sminus</code> <code>ndarray</code> <p>spin-down smatrix elements</p> required <p>Returns:</p> Name Type Description <code>dsdo</code> <code>ndarray</code> <p>differential cross section (fm^2)</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def dsdo(self, alpha: np.array, Splus: np.array, Sminus: np.array):\n    r\"\"\"Gives the differential cross section (dsigma/dOmega = dsdo) in mb/Sr.\n\n    Parameters:\n        alpha (ndarray): parameter-space vector\n        Splus (ndarray): spin-up smatrix elements\n        Sminus (ndarray): spin-down smatrix elements\n\n    Returns:\n        dsdo (ndarray): differential cross section (fm^2)\n\n    \"\"\"\n    k = self.rbes[0][0].interaction.momentum(alpha)\n\n    Splus = Splus[:, np.newaxis]\n    Sminus = Sminus[:, np.newaxis]\n    lmax = Splus.shape[0]\n    l = self.ls[:lmax]\n\n    A = self.f_c + (1 / (2j * k)) * np.sum(\n        np.exp(2j * self.sigma_l[:lmax])\n        * ((l + 1) * (Splus - 1) + l * (Sminus - 1))\n        * self.P_l_costheta[:lmax, ...],\n        axis=0,\n    )\n    B = (1 / (2j * k)) * np.sum(\n        np.exp(2j * self.sigma_l[:lmax])\n        * (Splus - Sminus)\n        * self.P_1_l_costheta[:lmax, ...],\n        axis=0,\n    )\n\n    dsdo = 10 * (np.conj(A) * A + np.conj(B) * B).real\n    if self.k_c &gt; 0:\n        return dsdo / self.rutherford\n    else:\n        return dsdo\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.emulate_dsdo","title":"<code>emulate_dsdo(alpha)</code>","text":"<p>Emulates the differential cross section (dsigma/dOmega = dsdo) in mb/Sr.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter-space vector</p> required <p>Returns:</p> Name Type Description <code>dsdo</code> <code>ndarray</code> <p>emulated differential cross section</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def emulate_dsdo(self, alpha: np.array):\n    r\"\"\"Emulates the differential cross section (dsigma/dOmega = dsdo) in mb/Sr.\n\n    Parameters:\n        alpha (ndarray): parameter-space vector\n\n    Returns:\n        dsdo (ndarray): emulated differential cross section\n\n    \"\"\"\n    Splus, Sminus = self.emulate_smatrix_elements(alpha)\n    return self.dsdo(alpha, Splus, Sminus)\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.emulate_phase_shifts","title":"<code>emulate_phase_shifts(alpha)</code>","text":"<p>Gives the phase shifts for each partial wave.  Order is [l=0, l=1,     ..., l=l_max-1].</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter-space vector</p> required <p>Returns:</p> Name Type Description <code>phase_shift</code> <code>list</code> <p>emulated phase shifts</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def emulate_phase_shifts(self, alpha: np.array):\n    r\"\"\"Gives the phase shifts for each partial wave.  Order is [l=0, l=1,\n        ..., l=l_max-1].\n\n    Parameters:\n        alpha (ndarray): parameter-space vector\n\n    Returns:\n        phase_shift (list): emulated phase shifts\n\n    \"\"\"\n    return [\n        [rbe.emulate_phase_shift(alpha) for rbe in rbe_list]\n        for rbe_list in self.rbes\n    ]\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.emulate_rmatrix_elements","title":"<code>emulate_rmatrix_elements(alpha)</code>","text":"<p>Returns: Rl_plus (ndarray) : l-s aligned R-matrix elements for partial waves Rl_minus (ndarray) : same as Splus, but l-s anti-aligned</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def emulate_rmatrix_elements(self, alpha):\n    r\"\"\"Returns:\n    Rl_plus (ndarray) : l-s aligned R-matrix elements for partial waves\n    Rl_minus (ndarray) : same as Splus, but l-s anti-aligned\n    \"\"\"\n    Rplus = np.array(\n        [\n            rbe_list[0].R_matrix_element(alpha)\n            for rbe_list in self.rbes[0 : self.l_max]\n        ]\n    )\n    Rminus = np.array(\n        [Rplus[0]]\n        + [\n            rbe_list[1].R_matrix_element(alpha)\n            for rbe_list in self.rbes[1 : self.l_max]\n        ]\n    )\n    return Rplus, Rminus\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.emulate_smatrix_elements","title":"<code>emulate_smatrix_elements(alpha)</code>","text":"<p>Sl_plus (ndarray) : l-s aligned S-matrix elements for partial waves up to where     Splus &lt; Smatrix_abs_tol Sl_minus (ndarray) : same as Splus, but l-s anti-aligned</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def emulate_smatrix_elements(self, alpha):\n    r\"\"\"Returns:\n    Sl_plus (ndarray) : l-s aligned S-matrix elements for partial waves up to where\n        Splus &lt; Smatrix_abs_tol\n    Sl_minus (ndarray) : same as Splus, but l-s anti-aligned\n    \"\"\"\n    Splus = np.zeros(self.l_max, dtype=np.complex128)\n    Sminus = np.zeros(self.l_max, dtype=np.complex128)\n    Splus[0] = self.rbes[0][0].S_matrix_element(alpha)\n    Sminus[0] = Splus[0]\n    for l in range(1, self.l_max):\n        Splus[l] = self.rbes[l][0].S_matrix_element(alpha)\n        Sminus[l] = self.rbes[l][1].S_matrix_element(alpha)\n        if (\n            np.absolute(Splus[l]) &lt; self.Smatrix_abs_tol\n            and np.absolute(Sminus[l]) &lt; self.Smatrix_abs_tol\n        ):\n            break\n\n    return Splus[:l], Sminus[:l]\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.emulate_wave_functions","title":"<code>emulate_wave_functions(alpha)</code>","text":"<p>Gives the wave functions for each partial wave.  Returns a list of     arrays.  Order is [l=0, l=1, ..., l=l_max-1].</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter-space vector</p> required <p>Returns:</p> Name Type Description <code>wave_functions</code> <code>list</code> <p>emulated wave functions</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def emulate_wave_functions(self, alpha: np.array):\n    r\"\"\"Gives the wave functions for each partial wave.  Returns a list of\n        arrays.  Order is [l=0, l=1, ..., l=l_max-1].\n\n    Parameters:\n        alpha (ndarray): parameter-space vector\n\n    Returns:\n        wave_functions (list): emulated wave functions\n\n\n    \"\"\"\n    return [[x.emulate_wave_function(alpha) for x in rbe] for rbe in self.rbes]\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.emulate_xs","title":"<code>emulate_xs(alpha, angles=None)</code>","text":"<p>Emulates the: - differential cross section in mb/Sr (as a ratio to a Rutherford xs if provided) - analyzing power - total and reacion cross sections in mb</p> Paramaters <p>alpha (ndarray) : interaction parameters angles (ndarray) : (optional), angular grid on which to evaluate analyzing \\ powers and differential cross section</p> Returns <p>cross sections (NucleonNucleusXS) :</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def emulate_xs(self, alpha: np.array, angles: np.array = None):\n    r\"\"\"Emulates the:\n        - differential cross section in mb/Sr (as a ratio to a Rutherford xs if provided)\n        - analyzing power\n        - total and reacion cross sections in mb\n\n        Paramaters:\n            alpha (ndarray) : interaction parameters\n            angles (ndarray) : (optional), angular grid on which to evaluate analyzing \\\n            powers and differential cross section\n\n        Returns :\n            cross sections (NucleonNucleusXS) :\n    \"\"\"\n    # get phase shifts and wavenumber\n    Splus, Sminus = self.emulate_smatrix_elements(alpha)\n    return self.calculate_xs(Splus, Sminus, alpha, angles)\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.exact_dsdo","title":"<code>exact_dsdo(alpha)</code>","text":"<p>Calculates the high-fidelity differential cross section (dsigma/dOmega = dsdo) in mb/Sr.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter-space vector</p> required <p>Returns:</p> Name Type Description <code>dsdo</code> <code>ndarray</code> <p>high-fidelity differential cross section</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def exact_dsdo(self, alpha: np.array):\n    r\"\"\"Calculates the high-fidelity differential cross section (dsigma/dOmega = dsdo) in mb/Sr.\n\n    Parameters:\n        alpha (ndarray): parameter-space vector\n\n    Returns:\n        dsdo (ndarray): high-fidelity differential cross section\n\n    \"\"\"\n    Splus, Sminus = self.exact_smatrix_elements(alpha)\n    return self.dsdo(alpha, Splus, Sminus)\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.exact_phase_shifts","title":"<code>exact_phase_shifts(alpha)</code>","text":"<p>Gives the phase shifts for each partial wave. Order is [l=0, l=1,     ..., l=l_max-1].</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter-space vector</p> required <p>Returns:</p> Name Type Description <code>phase_shift</code> <code>list</code> <p>high-fidelity phase shifts</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def exact_phase_shifts(self, alpha: np.array):\n    r\"\"\"Gives the phase shifts for each partial wave. Order is [l=0, l=1,\n        ..., l=l_max-1].\n\n    Parameters:\n        alpha (ndarray): parameter-space vector\n\n    Returns:\n        phase_shift (list): high-fidelity phase shifts\n\n    \"\"\"\n    return [\n        [rbe.basis.solver.delta(alpha) for rbe in rbe_list]\n        for rbe_list in self.rbes\n    ]\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.exact_rmatrix_elements","title":"<code>exact_rmatrix_elements(alpha)</code>","text":"<p>Returns: Rl_plus (ndarray) : l-s aligned R-matrix elements for partial waves up to where Rl_minus (ndarray) : same as Splus, but l-s anti-aligned</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def exact_rmatrix_elements(self, alpha):\n    r\"\"\"Returns:\n    Rl_plus (ndarray) : l-s aligned R-matrix elements for partial waves up to where\n    Rl_minus (ndarray) : same as Splus, but l-s anti-aligned\n    \"\"\"\n    Rplus = np.array(\n        [\n            rbe_list[0].basis.solver.rmatrix(alpha)\n            for rbe_list in self.rbes[0 : self.l_max]\n        ]\n    )\n    Rminus = np.array(\n        [Rplus[0]]\n        + [\n            rbe_list[1].basis.solver.rmatrix(alpha)\n            for rbe_list in self.rbes[1 : self.l_max]\n        ]\n    )\n    return Rplus, Rminus\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.exact_smatrix_elements","title":"<code>exact_smatrix_elements(alpha)</code>","text":"<p>Sl_plus (ndarray) : l-s aligned S-matrix elements for partial waves up to where     Splus.real - 1 &lt; Smatrix_abs_tol Sl_minus (ndarray) : same as Splus, but l-s anti-aligned</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def exact_smatrix_elements(self, alpha):\n    r\"\"\"Returns:\n    Sl_plus (ndarray) : l-s aligned S-matrix elements for partial waves up to where\n        Splus.real - 1 &lt; Smatrix_abs_tol\n    Sl_minus (ndarray) : same as Splus, but l-s anti-aligned\n    \"\"\"\n\n    Splus = np.zeros(self.l_max, dtype=np.complex128)\n    Sminus = np.zeros(self.l_max, dtype=np.complex128)\n    Splus[0] = self.rbes[0][0].basis.solver.smatrix(alpha)\n    for l in range(1, self.l_max):\n        Splus[l] = self.rbes[l][0].basis.solver.smatrix(alpha)\n        Sminus[l] = self.rbes[l][1].basis.solver.smatrix(alpha)\n        if (\n            np.absolute(1 - Splus[l]) &lt; self.Smatrix_abs_tol\n            and np.absolute(1 - Sminus[l]) &lt; self.Smatrix_abs_tol\n        ):\n            break\n\n    return Splus[:l], Sminus[:l]\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.exact_wave_functions","title":"<code>exact_wave_functions(alpha, s_mesh=None, **solver_kwargs)</code>","text":"<p>Gives the wave functions for each partial wave.  Returns a list of     arrays.  Order is [l=0, l=1, ..., l=l_max-1].</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray</code> <p>parameter-space vector</p> required <code>s_mesh</code> <code>ndarray</code> <p>s_mesh on which to evaluate phi, if different from the one used for emulation</p> <code>None</code> <code>solver_kwargs</code> <code>ndarray</code> <p>passed to SchroedingerEquation.phi</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>wave_functions</code> <code>list</code> <p>emulated wave functions</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def exact_wave_functions(\n    self, alpha: np.array, s_mesh: np.array = None, **solver_kwargs\n):\n    r\"\"\"Gives the wave functions for each partial wave.  Returns a list of\n        arrays.  Order is [l=0, l=1, ..., l=l_max-1].\n\n    Parameters:\n        alpha (ndarray): parameter-space vector\n        s_mesh (ndarray): s_mesh on which to evaluate phi, if different from the one used\n            for emulation\n        solver_kwargs (ndarray): passed to SchroedingerEquation.phi\n\n    Returns:\n        wave_functions (list): emulated wave functions\n\n\n    \"\"\"\n    if s_mesh is None:\n        return [\n            [x.basis.solver.phi(alpha, x.s_mesh, **solver_kwargs) for x in rbe]\n            for rbe in self.rbes\n        ]\n    else:\n        return [\n            [x.basis.solver.phi(alpha, s_mesh, **solver_kwargs) for x in rbe]\n            for rbe in self.rbes\n        ]\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.exact_xs","title":"<code>exact_xs(alpha, angles=None)</code>","text":"<p>Calculates the exact: - differential cross section in mb/Sr (as a ratio to a Rutherford xs if provided) - analyzing power - total and reacion cross sections in mb</p> Paramaters <p>alpha (ndarray) : interaction parameters angles (ndarray) : (optional), angular grid on which to evaluate analyzing \\ powers and differential cross section</p> Returns <p>cross sections (NucleonNucleusXS) :</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def exact_xs(self, alpha: np.array, angles: np.array = None):\n    r\"\"\"Calculates the exact:\n        - differential cross section in mb/Sr (as a ratio to a Rutherford xs if provided)\n        - analyzing power\n        - total and reacion cross sections in mb\n\n        Paramaters:\n            alpha (ndarray) : interaction parameters\n            angles (ndarray) : (optional), angular grid on which to evaluate analyzing \\\n            powers and differential cross section\n\n        Returns :\n            cross sections (NucleonNucleusXS) :\n    \"\"\"\n    # get phase shifts and wavenumber\n    Splus, Sminus = self.exact_smatrix_elements(alpha)\n    return self.calculate_xs(Splus, Sminus, alpha, angles)\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.from_train","title":"<code>from_train(interaction_space, alpha_train, base_solver=None, l_max=None, angles=DEFAULT_ANGLE_MESH, n_basis=4, use_svd=True, Smatrix_abs_tol=1e-06, s_mesh=None, **basis_kwargs)</code>  <code>classmethod</code>","text":"<p>Trains a reduced-basis emulator based on the provided interaction and training space.</p> <p>Parameters:</p> Name Type Description Default <code>interaction_space</code> <code>InteractionSpace</code> <p>local interaction up to (and including $\\ell_\\max$)</p> required <code>alpha_train</code> <code>ndarray</code> <p>training points in parameter space; shape = (n_points, n_parameters)</p> required <code>base_solver </code> <p>the solver used for training the emulator, and for calculations of exact observables. Must be an instance of SchroedingerEquation or a derived class of it. The solvers for each <code>interaction</code> in <code>interaction_space</code> will be constructed using</p> required <code>l_max</code> <code>int</code> <p>maximum angular momentum to include in the sum approximating the cross section</p> <code>None</code> <code>angles</code> <code>ndarray</code> <p>Differential cross sections are functions of the angles. These are the specific values at which the user wants to emulate the cross section.</p> <code>DEFAULT_ANGLE_MESH</code> <code>n_basis</code> <code>int</code> <p>number of basis vectors for $\\hat{\\phi}$ expansion</p> <code>4</code> <code>use_svd</code> <code>bool</code> <p>Use principal components of training wave functions?</p> <code>True</code> <code>s_mesh</code> <code>ndarray</code> <p>$s$ (or $\\rho$) grid on which wave functions are evaluated</p> <code>None</code> <code>s_0</code> <code>float</code> <p>$s$ point where the phase shift is extracted</p> required <code>Smatrix_abs_tol </code> <p>absolute tolerance for deviation of real part of S-matrix amplitudes from 1, used as criteria to stop calculation ig higher partial waves are negligble</p> required <p>Returns:</p> Name Type Description <code>sae</code> <code>ScatteringAmplitudeEmulator</code> <p>scattering amplitude emulator</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>@classmethod\ndef from_train(\n    cls,\n    interaction_space: InteractionSpace,\n    alpha_train: np.array,\n    base_solver: SchroedingerEquation = None,\n    l_max: int = None,\n    angles: np.array = DEFAULT_ANGLE_MESH,\n    n_basis: int = 4,\n    use_svd: bool = True,\n    Smatrix_abs_tol: float = 1.0e-6,\n    s_mesh: np.array = None,\n    **basis_kwargs,\n):\n    r\"\"\"Trains a reduced-basis emulator based on the provided interaction and training space.\n\n    Parameters:\n        interaction_space (InteractionSpace): local interaction up to (and including $\\ell_\\max$)\n        alpha_train (ndarray): training points in parameter space; shape = (n_points, n_parameters)\n        base_solver : the solver used for training the emulator, and for calculations of exact\n            observables. Must be an instance of SchroedingerEquation or a derived class of it.\n            The solvers for each `interaction` in `interaction_space` will be constructed using\n        l_max (int): maximum angular momentum to include in the sum approximating the cross section\n        angles (ndarray): Differential cross sections are functions of the\n            angles. These are the specific values at which the user wants to\n            emulate the cross section.\n        n_basis (int): number of basis vectors for $\\hat{\\phi}$ expansion\n        use_svd (bool): Use principal components of training wave functions?\n        s_mesh (ndarray): $s$ (or $\\rho$) grid on which wave functions are evaluated\n        s_0 (float): $s$ point where the phase shift is extracted\n        Smatrix_abs_tol : absolute tolerance for deviation of real part of S-matrix amplitudes\n            from 1, used as criteria to stop calculation ig higher partial waves are negligble\n\n    Returns:\n        sae (ScatteringAmplitudeEmulator): scattering amplitude emulator\n\n    \"\"\"\n    if base_solver is None:\n        base_solver = SchroedingerEquation.make_base_solver()\n\n    if l_max is None:\n        l_max = interaction_space.l_max\n\n    bases = []\n    for interaction_list in tqdm(interaction_space.interactions):\n        basis_list = []\n        for interaction in interaction_list:\n            solver = base_solver.clone_for_new_interaction(interaction)\n            if s_mesh is None:\n                s_mesh = np.linspace(\n                    solver.domain[0],\n                    solver.domain[1],\n                    SchroedingerEquation.DEFAULT_NUM_PTS,\n                )\n            basis_list.append(\n                RelativeBasis(\n                    solver,\n                    alpha_train,\n                    s_mesh,\n                    n_basis,\n                    use_svd=use_svd,\n                    **basis_kwargs,\n                )\n            )\n        bases.append(basis_list)\n\n    return cls(\n        interaction_space,\n        bases,\n        l_max,\n        angles=angles,\n        s_0=base_solver.s_0,\n        Smatrix_abs_tol=Smatrix_abs_tol,\n    )\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.load","title":"<code>load(obj, filename)</code>  <code>classmethod</code>","text":"<p>Loads a previously trained emulator.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>string</code> <p>name of file</p> required <p>Returns:</p> Name Type Description <code>emulator</code> <code>ScatteringAmplitudeEmulator</code> <p>previously trainined <code>ScatteringAmplitudeEmulator</code></p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>@classmethod\ndef load(obj, filename):\n    r\"\"\"Loads a previously trained emulator.\n\n    Parameters:\n        filename (string): name of file\n\n    Returns:\n        emulator (ScatteringAmplitudeEmulator): previously trainined `ScatteringAmplitudeEmulator`\n\n    \"\"\"\n    with open(filename, \"rb\") as f:\n        sae = pickle.load(f)\n    return sae\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.percent_explained_variance","title":"<code>percent_explained_variance()</code>","text":"<p>Returns:</p> Type Description <p>(float) : percent of variance explained in the training set by the first n_basis principal</p> <p>components</p> Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def percent_explained_variance(self):\n    r\"\"\"\n    Returns:\n        (float) : percent of variance explained in the training set by the first n_basis principal\n        components\n    \"\"\"\n    return [\n        [rbe.basis.percent_explained_variance() for rbe in rbe_list]\n        for rbe_list in self.rbes\n    ]\n</code></pre>"},{"location":"sae/#rose.scattering_amplitude_emulator.ScatteringAmplitudeEmulator.save","title":"<code>save(filename)</code>","text":"<p>Saves the emulator to the desired file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>string</code> <p>name of file</p> required Source code in <code>src/rose/scattering_amplitude_emulator.py</code> <pre><code>def save(self, filename):\n    r\"\"\"Saves the emulator to the desired file.\n\n    Parameters:\n        filename (string): name of file\n\n    \"\"\"\n    with open(filename, \"wb\") as f:\n        pickle.dump(self, f)\n</code></pre>"},{"location":"tutorials/ROSE_Add_your_own_HF_solver/","title":"Adding your own custom high-fidelity solver","text":"In\u00a0[1]: Copied! <pre>import rose\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom pathlib import Path\nimport pickle\nfrom tqdm import tqdm\n</pre> import rose import numpy as np from matplotlib import pyplot as plt from pathlib import Path import pickle from tqdm import tqdm In\u00a0[2]: Copied! <pre>from matplotlib import colormaps as cm\nfrom matplotlib import pyplot as plt\nfrom matplotlib import rcParams\nfrom matplotlib.lines import Line2D\nfrom matplotlib.ticker import MaxNLocator, StrMethodFormatter\nfrom rose.training import multiple_formatter\n\ncolors = [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\",\n]\n\nplt.rc(\"font\", **{\"family\": \"serif\", \"serif\": [\"Computer Modern\"]})\nrcParams[\"text.latex.preamble\"] = (\n    r\"\\usepackage{amssymb} \\usepackage{amsmath} \\usepackage{braket}\"\n)\nplt.rc(\"text\", usetex=True)\n\nrcParams[\"legend.fontsize\"] = 12\nrcParams[\"font.size\"] = 12\nrcParams[\"font.weight\"] = \"normal\"\nrcParams[\"xtick.labelsize\"] = 12.0\nrcParams[\"ytick.labelsize\"] = 12.0\nrcParams[\"lines.linewidth\"] = 2.0\nrcParams[\"xtick.major.pad\"] = \"10\"\nrcParams[\"ytick.major.pad\"] = \"10\"\nrcParams[\"image.cmap\"] = \"BuPu\"\n</pre> from matplotlib import colormaps as cm from matplotlib import pyplot as plt from matplotlib import rcParams from matplotlib.lines import Line2D from matplotlib.ticker import MaxNLocator, StrMethodFormatter from rose.training import multiple_formatter  colors = [     \"#1f77b4\",     \"#ff7f0e\",     \"#2ca02c\",     \"#d62728\",     \"#9467bd\",     \"#8c564b\",     \"#e377c2\",     \"#7f7f7f\",     \"#bcbd22\",     \"#17becf\", ]  plt.rc(\"font\", **{\"family\": \"serif\", \"serif\": [\"Computer Modern\"]}) rcParams[\"text.latex.preamble\"] = (     r\"\\usepackage{amssymb} \\usepackage{amsmath} \\usepackage{braket}\" ) plt.rc(\"text\", usetex=True)  rcParams[\"legend.fontsize\"] = 12 rcParams[\"font.size\"] = 12 rcParams[\"font.weight\"] = \"normal\" rcParams[\"xtick.labelsize\"] = 12.0 rcParams[\"ytick.labelsize\"] = 12.0 rcParams[\"lines.linewidth\"] = 2.0 rcParams[\"xtick.major.pad\"] = \"10\" rcParams[\"ytick.major.pad\"] = \"10\" rcParams[\"image.cmap\"] = \"BuPu\" In\u00a0[3]: Copied! <pre># !pip install jitr\nimport jitr\nfrom numba import njit\n</pre> # !pip install jitr import jitr from numba import njit In\u00a0[4]: Copied! <pre># set up kinematics\nfrom rose.koning_delaroche import KDGlobal, Projectile\n\n# for 27-Al\nA = 27\nZ = 13\n\n# lab bombarding energy\nE_lab = 35  # MeV\n\n# get kinematics and default KD params\nmu, E_com, k, eta = rose.utility.kinematics((A,Z), (1,0), E_lab=E_lab)\nomp = rose.koning_delaroche.KDGlobal(Projectile.neutron)\nR_C, parameters = omp.get_params(A, Z, mu, E_com, k)\n</pre> # set up kinematics from rose.koning_delaroche import KDGlobal, Projectile  # for 27-Al A = 27 Z = 13  # lab bombarding energy E_lab = 35  # MeV  # get kinematics and default KD params mu, E_com, k, eta = rose.utility.kinematics((A,Z), (1,0), E_lab=E_lab) omp = rose.koning_delaroche.KDGlobal(Projectile.neutron) R_C, parameters = omp.get_params(A, Z, mu, E_com, k) In\u00a0[5]: Copied! <pre># take train and test parameter samples from a box bounded\n# 50% above and below the default values\nscale = 0.25\n\nbounds = np.array(\n    [\n        parameters - np.fabs(scale * parameters),\n        parameters + np.fabs(scale * parameters),\n    ]\n).T\n</pre> # take train and test parameter samples from a box bounded # 50% above and below the default values scale = 0.25  bounds = np.array(     [         parameters - np.fabs(scale * parameters),         parameters + np.fabs(scale * parameters),     ] ).T In\u00a0[6]: Copied! <pre>from rose.training import sample_params_LHC\n\n# sample points for a train/test split\n# sample from +/-50% around the default params using Latin hypercube\nn_train = 100\nn_test = 100\ntraining_samples = sample_params_LHC(n_train, parameters, scale, seed=13)\n# grab some test parameters\ntest_samples = rose.training.sample_params_LHC(n_test, parameters, scale, seed=1233)\n</pre> from rose.training import sample_params_LHC  # sample points for a train/test split # sample from +/-50% around the default params using Latin hypercube n_train = 100 n_test = 100 training_samples = sample_params_LHC(n_train, parameters, scale, seed=13) # grab some test parameters test_samples = rose.training.sample_params_LHC(n_test, parameters, scale, seed=1233) <p>To use the <code>jitr</code> package as a custom solver in <code>rose</code>, we will need to use a derived class of <code>rose.SchroedingerEquation</code>: <code>LagrangeRmatrix</code>. This class is located in <code>src/rose/lagrangelegendersolver.py</code>, and can serve as a template example for interfacing external solvers in ROSE.</p> <p>Let's set up the system:</p> In\u00a0[7]: Copied! <pre>nodes_within_radius = 3\ns_0 = nodes_within_radius * (2 * np.pi) # channel matching radius\n\nangles = np.linspace(1e-3, np.pi, 300)\ns_mesh = np.linspace(1e-10, s_0, 1000)\ndomain = [s_mesh[0], s_0]\n</pre> nodes_within_radius = 3 s_0 = nodes_within_radius * (2 * np.pi) # channel matching radius  angles = np.linspace(1e-3, np.pi, 300) s_mesh = np.linspace(1e-10, s_0, 1000) domain = [s_mesh[0], s_0] In\u00a0[8]: Copied! <pre># create an interaction space for partial waves\n\ninteractions = rose.InteractionEIMSpace(\n    coordinate_space_potential=rose.koning_delaroche.KD_simple,\n    n_theta=len(parameters),\n    mu=mu,\n    energy=E_com,\n    is_complex=True,\n    spin_orbit_term=rose.koning_delaroche.KD_simple_so,\n    training_info=bounds,\n    Z_1=0,\n    Z_2=13,\n    R_C=R_C,\n    l_max=20,\n    expl_var_ratio_cutoff=1.0e-6,\n    rho_mesh=s_mesh,\n)\n</pre> # create an interaction space for partial waves  interactions = rose.InteractionEIMSpace(     coordinate_space_potential=rose.koning_delaroche.KD_simple,     n_theta=len(parameters),     mu=mu,     energy=E_com,     is_complex=True,     spin_orbit_term=rose.koning_delaroche.KD_simple_so,     training_info=bounds,     Z_1=0,     Z_2=13,     R_C=R_C,     l_max=20,     expl_var_ratio_cutoff=1.0e-6,     rho_mesh=s_mesh, ) In\u00a0[9]: Copied! <pre>rk_domain = [domain[0], domain[1] + np.pi]  # extend rk domain past s_0\nhifi_solver = rose.SchroedingerEquation.make_base_solver(\n        rk_tols=[1e-10, 1e-10], s_0=s_0, domain=rk_domain\n)\n\nemu = rose.ScatteringAmplitudeEmulator.from_train(\n    interactions,\n    training_samples,\n    base_solver=hifi_solver,\n    n_basis=20,\n    angles=angles,\n    s_mesh=s_mesh,\n    scale=True,\n    use_svd=True,\n)\n</pre> rk_domain = [domain[0], domain[1] + np.pi]  # extend rk domain past s_0 hifi_solver = rose.SchroedingerEquation.make_base_solver(         rk_tols=[1e-10, 1e-10], s_0=s_0, domain=rk_domain )  emu = rose.ScatteringAmplitudeEmulator.from_train(     interactions,     training_samples,     base_solver=hifi_solver,     n_basis=20,     angles=angles,     s_mesh=s_mesh,     scale=True,     use_svd=True, ) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 21/21 [04:38&lt;00:00, 13.26s/it]\n</pre> In\u00a0[10]: Copied! <pre>from matplotlib.lines import Line2D\n\nf, ax = plt.subplots(1,1, figsize=(6,4), facecolor=\"white\", dpi=600)\n\nfor sample in test_samples[::2]:\n    p = plt.plot(s_mesh, emu.rbes[0][0].interaction.tilde(s_mesh, sample), alpha=0.5)[0]\n    plt.plot(\n        s_mesh,\n        emu.rbes[0][0].interaction.tilde_emu(sample),\n        \":\",\n        alpha=0.5,\n        color=p.get_color(),\n    )\nlegend_styles = [\n    Line2D([0], [0], color=\"tab:gray\", linestyle=\":\", alpha=0.8),\n    Line2D([0], [0], color=\"tab:gray\", alpha=0.8),\n]\nleg = plt.legend(\n    legend_styles,\n    [\"EIM\", \"Exact\",],\n    loc=\"lower right\",\n)\nax.xaxis.set_major_locator(plt.MultipleLocator(np.pi/2))\nax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=2)))\nplt.ylabel(r\"$U(s; \\alpha)$\")\nplt.xlabel(r\"$s = kr$\")\nplt.xlim([0,8])\n</pre> from matplotlib.lines import Line2D  f, ax = plt.subplots(1,1, figsize=(6,4), facecolor=\"white\", dpi=600)  for sample in test_samples[::2]:     p = plt.plot(s_mesh, emu.rbes[0][0].interaction.tilde(s_mesh, sample), alpha=0.5)[0]     plt.plot(         s_mesh,         emu.rbes[0][0].interaction.tilde_emu(sample),         \":\",         alpha=0.5,         color=p.get_color(),     ) legend_styles = [     Line2D([0], [0], color=\"tab:gray\", linestyle=\":\", alpha=0.8),     Line2D([0], [0], color=\"tab:gray\", alpha=0.8), ] leg = plt.legend(     legend_styles,     [\"EIM\", \"Exact\",],     loc=\"lower right\", ) ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi/2)) ax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=2))) plt.ylabel(r\"$U(s; \\alpha)$\") plt.xlabel(r\"$s = kr$\") plt.xlim([0,8]) <pre>/home/kyle/mambaforge/envs/om/lib/python3.10/site-packages/matplotlib/cbook.py:1762: ComplexWarning: Casting complex values to real discards the imaginary part\n  return math.isfinite(val)\n/home/kyle/mambaforge/envs/om/lib/python3.10/site-packages/matplotlib/cbook.py:1398: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n</pre> Out[10]: <pre>(0.0, 8.0)</pre> In\u00a0[11]: Copied! <pre>plt.plot(angles, emu.exact_dsdo(test_samples[4]), alpha=0.5, label=\"exact\")\nplt.plot(angles, emu.emulate_dsdo(test_samples[4]), \":\", label=\"emu\")\n#plt.plot(angles, ground_truth_output[4], \":\", label=\"gto\")\nplt.yscale(\"log\")\nplt.legend()\n</pre> plt.plot(angles, emu.exact_dsdo(test_samples[4]), alpha=0.5, label=\"exact\") plt.plot(angles, emu.emulate_dsdo(test_samples[4]), \":\", label=\"emu\") #plt.plot(angles, ground_truth_output[4], \":\", label=\"gto\") plt.yscale(\"log\") plt.legend() Out[11]: <pre>&lt;matplotlib.legend.Legend at 0x7416cabf6aa0&gt;</pre> In\u00a0[12]: Copied! <pre>llrm_solver = rose.LagrangeRmatrix(\n    interactions.interactions[0][0],\n    s_0,\n    jitr.rmatrix.Solver(100),\n)\n\nllrm = rose.ScatteringAmplitudeEmulator.HIFI_solver(\n            interactions,\n            base_solver=llrm_solver,\n            angles=angles,\n            s_mesh=s_mesh,\n)\n</pre> llrm_solver = rose.LagrangeRmatrix(     interactions.interactions[0][0],     s_0,     jitr.rmatrix.Solver(100), )  llrm = rose.ScatteringAmplitudeEmulator.HIFI_solver(             interactions,             base_solver=llrm_solver,             angles=angles,             s_mesh=s_mesh, ) In\u00a0[13]: Copied! <pre># choose the highest fidelity Runge-Kutta solver as our 'ground truth'\nrk_domain = [domain[0], domain[1] + np.pi]  # extend rk domain past s_0\nhifi_solver = rose.SchroedingerEquation.make_base_solver(\n        rk_tols=[1e-11, 1e-11], s_0=s_0, domain=rk_domain\n)\nground_truth = rose.ScatteringAmplitudeEmulator.HIFI_solver(\n    interactions,\n    base_solver=hifi_solver,\n    angles=angles,\n    s_mesh=s_mesh,\n)\n</pre> # choose the highest fidelity Runge-Kutta solver as our 'ground truth' rk_domain = [domain[0], domain[1] + np.pi]  # extend rk domain past s_0 hifi_solver = rose.SchroedingerEquation.make_base_solver(         rk_tols=[1e-11, 1e-11], s_0=s_0, domain=rk_domain ) ground_truth = rose.ScatteringAmplitudeEmulator.HIFI_solver(     interactions,     base_solver=hifi_solver,     angles=angles,     s_mesh=s_mesh, ) <p>And that's it, we have our high-fidelity Lagrange-Legendre R-matrix solver and a Runge-Kutta solver. Let's compare them.</p> In\u00a0[14]: Copied! <pre>solutions_llrm = llrm.exact_wave_functions(parameters)\n</pre> solutions_llrm = llrm.exact_wave_functions(parameters) In\u00a0[15]: Copied! <pre>solutions_rk = ground_truth.exact_wave_functions(parameters)\n</pre> solutions_rk = ground_truth.exact_wave_functions(parameters) <p>First, let's compare partial waves without phase matching:</p> In\u00a0[16]: Copied! <pre>from rose.training import compare_partial_waves\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 4), dpi=300)\nfig.patch.set_facecolor(\"white\")\n\ncompare_partial_waves(\n    s_mesh,\n    [solutions_rk[0:3], solutions_llrm[0:3]],\n    [\"Runge-Kutta\", \"Lagrange-Legendre\"],\n    fig,\n    ax1,\n    ax2,\n)\n</pre> from rose.training import compare_partial_waves fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 4), dpi=300) fig.patch.set_facecolor(\"white\")  compare_partial_waves(     s_mesh,     [solutions_rk[0:3], solutions_llrm[0:3]],     [\"Runge-Kutta\", \"Lagrange-Legendre\"],     fig,     ax1,     ax2, ) Out[16]: <pre>(&lt;Figure size 2700x1200 with 2 Axes&gt;,\n &lt;Axes: xlabel='$s = kr$ [dimensionless]', ylabel='$\\\\mathfrak{Re} \\\\, u_{lj}(s)$ [a.u.]'&gt;,\n &lt;Axes: xlabel='$s = kr$ [dimensionless]', ylabel='$\\\\mathfrak{Im} \\\\, u_{lj}(s)$ [a.u.]'&gt;)</pre> <p>Now, let's match phases and look again:</p> In\u00a0[17]: Copied! <pre>#TODO wavefunction normalization convention\nfor l in range(len(solutions_rk)):\n    for j in range(len(solutions_rk[l])):\n        i = 20\n        solutions_llrm[l][j] *= (\n            solutions_rk[l][j][i] / solutions_llrm[l][j][i])\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 4), dpi=300)\nfig.patch.set_facecolor(\"white\")\n\ncompare_partial_waves(\n    s_mesh,\n    [solutions_rk[0:3], solutions_llrm[0:3]],\n    [\"Runge-Kutta\", \"Lagrange-Legendre\"],\n    fig,\n    ax1,\n    ax2,\n)\n</pre> #TODO wavefunction normalization convention for l in range(len(solutions_rk)):     for j in range(len(solutions_rk[l])):         i = 20         solutions_llrm[l][j] *= (             solutions_rk[l][j][i] / solutions_llrm[l][j][i])  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 4), dpi=300) fig.patch.set_facecolor(\"white\")  compare_partial_waves(     s_mesh,     [solutions_rk[0:3], solutions_llrm[0:3]],     [\"Runge-Kutta\", \"Lagrange-Legendre\"],     fig,     ax1,     ax2, ) Out[17]: <pre>(&lt;Figure size 2700x1200 with 2 Axes&gt;,\n &lt;Axes: xlabel='$s = kr$ [dimensionless]', ylabel='$\\\\mathfrak{Re} \\\\, u_{lj}(s)$ [a.u.]'&gt;,\n &lt;Axes: xlabel='$s = kr$ [dimensionless]', ylabel='$\\\\mathfrak{Im} \\\\, u_{lj}(s)$ [a.u.]'&gt;)</pre> <p>Now, let's take a look at phase shifts:</p> In\u00a0[18]: Copied! <pre>deltas_rk = ground_truth.exact_phase_shifts(parameters)\n</pre> deltas_rk = ground_truth.exact_phase_shifts(parameters) In\u00a0[19]: Copied! <pre>deltas_llrm = llrm.exact_phase_shifts(parameters)\n</pre> deltas_llrm = llrm.exact_phase_shifts(parameters) In\u00a0[20]: Copied! <pre>from rose.training import plot_phase_shifts, compare_phase_shifts_err\nfrom matplotlib import ticker\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(\n    2, 2, sharex=True, figsize=(9, 5), height_ratios=[1, 0.5], dpi=300\n)\nfig.patch.set_facecolor(\"white\")\n\ncompare_phase_shifts_err(\n    deltas_rk,\n    deltas_llrm,\n    \"Runge-Kutta\",\n    \"Lagrange-Legendre\",\n    fig,\n    ax1,\n    ax2,\n    ax3,\n    ax4,\n    small_label1=\"RK\",\n    small_label2=\"N\",\n)\n\nplt.tight_layout()\n</pre> from rose.training import plot_phase_shifts, compare_phase_shifts_err from matplotlib import ticker  fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(     2, 2, sharex=True, figsize=(9, 5), height_ratios=[1, 0.5], dpi=300 ) fig.patch.set_facecolor(\"white\")  compare_phase_shifts_err(     deltas_rk,     deltas_llrm,     \"Runge-Kutta\",     \"Lagrange-Legendre\",     fig,     ax1,     ax2,     ax3,     ax4,     small_label1=\"RK\",     small_label2=\"N\", )  plt.tight_layout() In\u00a0[21]: Copied! <pre>rk_tolerances = [(1e-5, 1e-5), (1e-7, 1e-7), (1e-9, 1e-9)]\nrk_solvers = []\n\nfor rk_tols in rk_tolerances:\n    solver = rose.SchroedingerEquation.make_base_solver(\n        rk_tols=rk_tols, s_0=s_0, domain=rk_domain\n    )\n    rk_solvers.append(\n        rose.ScatteringAmplitudeEmulator.HIFI_solver(\n            interactions, base_solver=solver, angles=angles, s_mesh=s_mesh\n        )\n    )\n</pre> rk_tolerances = [(1e-5, 1e-5), (1e-7, 1e-7), (1e-9, 1e-9)] rk_solvers = []  for rk_tols in rk_tolerances:     solver = rose.SchroedingerEquation.make_base_solver(         rk_tols=rk_tols, s_0=s_0, domain=rk_domain     )     rk_solvers.append(         rose.ScatteringAmplitudeEmulator.HIFI_solver(             interactions, base_solver=solver, angles=angles, s_mesh=s_mesh         )     ) In\u00a0[22]: Copied! <pre>nbases = [30, 50, 70]\nllrm_solvers = []\nfor n in nbases:\n    solver = rose.LagrangeRmatrix(\n        interactions.interactions[0][0],\n        s_0,\n        jitr.rmatrix.Solver(n)\n    )\n\n    llrm_solvers.append(\n        rose.ScatteringAmplitudeEmulator.HIFI_solver(\n            interactions,\n            base_solver=solver,\n            angles=angles,\n            s_mesh=s_mesh,\n        )\n    )\n</pre> nbases = [30, 50, 70] llrm_solvers = [] for n in nbases:     solver = rose.LagrangeRmatrix(         interactions.interactions[0][0],         s_0,         jitr.rmatrix.Solver(n)     )      llrm_solvers.append(         rose.ScatteringAmplitudeEmulator.HIFI_solver(             interactions,             base_solver=solver,             angles=angles,             s_mesh=s_mesh,         )     )  <p>Not bad! How does this translate to cross sections? Let's calculate $d\\sigma/d\\Omega$ for various instances of our interaction with different parameters.</p> In\u00a0[23]: Copied! <pre>%%time\n# calculate ground truth differential cross sections for each sample\nfpath = Path(\"ground_truth_rm_vs_rk_test.pkl\")\n\nif fpath.is_file():\n    with open(fpath, 'rb') as f:\n        ground_truth_output = pickle.load(f)\nelse:\n    ground_truth_output = []\n    for sample in tqdm(test_samples):\n        ground_truth_output.append(ground_truth.exact_xs(sample).dsdo)\n    with open(fpath, 'wb') as f:\n        pickle.dump(ground_truth_output, f)\n</pre> %%time # calculate ground truth differential cross sections for each sample fpath = Path(\"ground_truth_rm_vs_rk_test.pkl\")  if fpath.is_file():     with open(fpath, 'rb') as f:         ground_truth_output = pickle.load(f) else:     ground_truth_output = []     for sample in tqdm(test_samples):         ground_truth_output.append(ground_truth.exact_xs(sample).dsdo)     with open(fpath, 'wb') as f:         pickle.dump(ground_truth_output, f) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [06:19&lt;00:00,  3.79s/it]</pre> <pre>CPU times: user 6min 19s, sys: 3 s, total: 6min 22s\nWall time: 6min 19s\n</pre> <pre>\n</pre> In\u00a0[24]: Copied! <pre>%%time\n# calculate lowfi differential cross sections for each sample to compare\nlowfi_solver = llrm_solvers[1]\nlowfi_method = \"Lagrange-Legendre n={}\".format(nbases[1])\n\nlowfi_output = []\nfor sample in tqdm(test_samples):\n    lowfi_output.append(lowfi_solver.exact_xs(sample).dsdo)\n</pre> %%time # calculate lowfi differential cross sections for each sample to compare lowfi_solver = llrm_solvers[1] lowfi_method = \"Lagrange-Legendre n={}\".format(nbases[1])  lowfi_output = [] for sample in tqdm(test_samples):     lowfi_output.append(lowfi_solver.exact_xs(sample).dsdo) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 132.65it/s]</pre> <pre>CPU times: user 756 ms, sys: 2 ms, total: 758 ms\nWall time: 756 ms\n</pre> <pre>\n</pre> In\u00a0[25]: Copied! <pre>from matplotlib.lines import Line2D\nfrom rose.training import multiple_formatter\nfig, ax = plt.subplots(figsize=(9, 4), dpi=300)\nfig.patch.set_facecolor(\"white\")\n\n# only plot a few\nn2plot = 10\nfor xs_hifi, xs_lowfi in zip(ground_truth_output[:n2plot], lowfi_output[:n2plot]):\n    p = ax.plot(angles, xs_hifi, alpha=0.5)[0]\n    ax.plot(angles, xs_lowfi, \"--\", color=p.get_color(), alpha=0.5)\n\nlegend_styles = [\n    Line2D([0], [0], color=\"tab:gray\", linestyle=\"--\", alpha=0.8),\n    Line2D([0], [0], color=\"tab:gray\", alpha=0.8),\n]\nleg = plt.legend(\n    legend_styles,\n    [lowfi_method, \"Runge-Kutta [1e-11, 1e-11]\",],\n    loc=\"lower left\",\n)\n\nax.xaxis.set_major_locator(plt.MultipleLocator(np.pi/6))\nax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=6)))\nax.set_yscale(\"log\")\nax.set_ylabel(r\"$ d \\sigma / d\\Omega $ [mb/Sr]\")\nax.set_xlabel(r\"$\\theta$ [radians]\")\n</pre> from matplotlib.lines import Line2D from rose.training import multiple_formatter fig, ax = plt.subplots(figsize=(9, 4), dpi=300) fig.patch.set_facecolor(\"white\")  # only plot a few n2plot = 10 for xs_hifi, xs_lowfi in zip(ground_truth_output[:n2plot], lowfi_output[:n2plot]):     p = ax.plot(angles, xs_hifi, alpha=0.5)[0]     ax.plot(angles, xs_lowfi, \"--\", color=p.get_color(), alpha=0.5)  legend_styles = [     Line2D([0], [0], color=\"tab:gray\", linestyle=\"--\", alpha=0.8),     Line2D([0], [0], color=\"tab:gray\", alpha=0.8), ] leg = plt.legend(     legend_styles,     [lowfi_method, \"Runge-Kutta [1e-11, 1e-11]\",],     loc=\"lower left\", )  ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi/6)) ax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=6))) ax.set_yscale(\"log\") ax.set_ylabel(r\"$ d \\sigma / d\\Omega $ [mb/Sr]\") ax.set_xlabel(r\"$\\theta$ [radians]\") Out[25]: <pre>Text(0.5, 0, '$\\\\theta$ [radians]')</pre> <p>Looks like $n=50$ is pretty darn good, but it does have a few cases with minor disagreements to the high fidelity. Let's quantify this with a CAT plot:</p> In\u00a0[26]: Copied! <pre>from rose.training import CATPerformance\n</pre> from rose.training import CATPerformance In\u00a0[27]: Copied! <pre>%%time\nrk_solver_performances = []\nfor solver, tols in zip(rk_solvers, rk_tolerances):\n    label = r\"$\\left[{:1.0e} , {:1.0e}\\right]$\".format(*tols)\n    fpath = Path(\"perf_rk_{:1.0e}_{:1.0e}.pkl\".format(*tols))\n    if fpath.is_file():\n        with open(fpath, 'rb') as f:\n            perf = pickle.load(f)\n            rk_solver_performances.append(perf)\n    else:\n        rk_solver_performances.append(\n            CATPerformance(\n                benchmark_runner=lambda sample: solver.exact_xs(sample).dsdo,\n                benchmark_inputs=test_samples,\n                benchmark_ground_truth=ground_truth_output,\n                label=label,\n            )\n        )\n        with open(fpath, 'wb') as f:\n            pickle.dump(rk_solver_performances[-1], f)\n</pre> %%time rk_solver_performances = [] for solver, tols in zip(rk_solvers, rk_tolerances):     label = r\"$\\left[{:1.0e} , {:1.0e}\\right]$\".format(*tols)     fpath = Path(\"perf_rk_{:1.0e}_{:1.0e}.pkl\".format(*tols))     if fpath.is_file():         with open(fpath, 'rb') as f:             perf = pickle.load(f)             rk_solver_performances.append(perf)     else:         rk_solver_performances.append(             CATPerformance(                 benchmark_runner=lambda sample: solver.exact_xs(sample).dsdo,                 benchmark_inputs=test_samples,                 benchmark_ground_truth=ground_truth_output,                 label=label,             )         )         with open(fpath, 'wb') as f:             pickle.dump(rk_solver_performances[-1], f) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:26&lt;00:00,  3.80it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [01:00&lt;00:00,  1.66it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [02:30&lt;00:00,  1.50s/it]</pre> <pre>CPU times: user 3min 57s, sys: 3.83 s, total: 4min\nWall time: 3min 56s\n</pre> <pre>\n</pre> In\u00a0[28]: Copied! <pre>%%time\nllrm_solver_performances = []\nfor solver, n in zip(llrm_solvers, nbases):\n    label = r\"$N  = {}$\".format(n)\n    fpath = Path(\"perf_llrm_N_{}.pkl\".format(n))\n    if fpath.is_file():\n        with open(fpath, \"rb\") as f:\n            perf = pickle.load(f)\n            llrm_solver_performances.append(perf)\n    else:\n        llrm_solver_performances.append(\n            CATPerformance(\n                benchmark_runner=lambda sample: solver.exact_xs(sample).dsdo,\n                benchmark_inputs=test_samples,\n                benchmark_ground_truth=ground_truth_output,\n                label=label,\n            )\n        )\n        with open(fpath, \"wb\") as f:\n            pickle.dump(llrm_solver_performances[-1], f)\n</pre> %%time llrm_solver_performances = [] for solver, n in zip(llrm_solvers, nbases):     label = r\"$N  = {}$\".format(n)     fpath = Path(\"perf_llrm_N_{}.pkl\".format(n))     if fpath.is_file():         with open(fpath, \"rb\") as f:             perf = pickle.load(f)             llrm_solver_performances.append(perf)     else:         llrm_solver_performances.append(             CATPerformance(                 benchmark_runner=lambda sample: solver.exact_xs(sample).dsdo,                 benchmark_inputs=test_samples,                 benchmark_ground_truth=ground_truth_output,                 label=label,             )         )         with open(fpath, \"wb\") as f:             pickle.dump(llrm_solver_performances[-1], f) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 238.10it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 139.88it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:03&lt;00:00, 29.90it/s]</pre> <pre>CPU times: user 9.07 s, sys: 18 s, total: 27 s\nWall time: 4.49 s\n</pre> <pre>\n</pre> In\u00a0[29]: Copied! <pre># [basis size, number of terms in EIM decomposition]\nsae_configs = [(5, 5), (10, 10), (15, 15), (20, 20)]\n_, emulators = rose.training.build_sae_config_set(\n    sae_configs,\n    interactions,\n    training_samples,\n    bounds,\n    angles=angles,\n    base_solver=hifi_solver,\n    s_mesh=s_mesh,\n    scale=True,\n    use_svd=True,\n)\n</pre> # [basis size, number of terms in EIM decomposition] sae_configs = [(5, 5), (10, 10), (15, 15), (20, 20)] _, emulators = rose.training.build_sae_config_set(     sae_configs,     interactions,     training_samples,     bounds,     angles=angles,     base_solver=hifi_solver,     s_mesh=s_mesh,     scale=True,     use_svd=True, ) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 21/21 [07:12&lt;00:00, 20.59s/it]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [02:24&lt;00:00, 36.11s/it]\n</pre> In\u00a0[30]: Copied! <pre>emu = emulators[-1]\nplt.plot(angles, emu.exact_dsdo(test_samples[4]), alpha=0.5, label=\"exact\")\nplt.plot(angles, emu.emulate_dsdo(test_samples[4]), label=\"emu\")\nplt.plot(angles, ground_truth_output[4], \":\", label=\"gto\")\nplt.yscale(\"log\")\nplt.legend()\n</pre> emu = emulators[-1] plt.plot(angles, emu.exact_dsdo(test_samples[4]), alpha=0.5, label=\"exact\") plt.plot(angles, emu.emulate_dsdo(test_samples[4]), label=\"emu\") plt.plot(angles, ground_truth_output[4], \":\", label=\"gto\") plt.yscale(\"log\") plt.legend() Out[30]: <pre>&lt;matplotlib.legend.Legend at 0x7416ca7f7610&gt;</pre> In\u00a0[31]: Copied! <pre>rbm_performances = []\nfor solver, config in zip(emulators, sae_configs):\n    label = r\"$\\left({:d} , {:d}\\right)$\".format(*config)\n    fpath = Path(\"perf_rbm_{:d}_{:d}.pkl\".format(*config))\n    if fpath.is_file():\n        with open(fpath, \"rb\") as f:\n            perf = pickle.load(f)\n            rbm_performances.append(perf)\n    else:\n        rbm_performances.append(\n            CATPerformance(\n                benchmark_runner=lambda sample: solver.emulate_xs(sample).dsdo,\n                benchmark_inputs=test_samples,\n                benchmark_ground_truth=ground_truth_output,\n                label=label,\n            )\n        )\n        with open(fpath, \"wb\") as f:\n            pickle.dump(rbm_performances[-1], f)\n</pre> rbm_performances = [] for solver, config in zip(emulators, sae_configs):     label = r\"$\\left({:d} , {:d}\\right)$\".format(*config)     fpath = Path(\"perf_rbm_{:d}_{:d}.pkl\".format(*config))     if fpath.is_file():         with open(fpath, \"rb\") as f:             perf = pickle.load(f)             rbm_performances.append(perf)     else:         rbm_performances.append(             CATPerformance(                 benchmark_runner=lambda sample: solver.emulate_xs(sample).dsdo,                 benchmark_inputs=test_samples,                 benchmark_ground_truth=ground_truth_output,                 label=label,             )         )         with open(fpath, \"wb\") as f:             pickle.dump(rbm_performances[-1], f) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 395.88it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 372.39it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 331.67it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 248.11it/s]\n</pre> In\u00a0[32]: Copied! <pre># plot the Computational Accuracy vs. Time (CAT)\nfrom rose.training import CAT_plot\n\nfig, ax = CAT_plot(\n    [rk_solver_performances, llrm_solver_performances, rbm_performances[2:]],\n    labels=[\"Runge-Kutta [rtol, atol]\", \"Lagrange-Legendre\", \"RBM [$n_{rbm}$, $n_{eim}$]\"],\n    border_styles=[\":\", \"--\", \"-\"],\n)\nax.set_ylabel(r\"median relative error in $d \\sigma / d \\Omega$ [\\%]\", size=16)\nax.set_xlabel(r\"time per sample [s]\", size=16)\n\nax.set_ylim(1e-10,10)\nax.set_xlim(1e-3,3)\nplt.tight_layout()\nplt.savefig(\"cat_rbm_rm_rk.pdf\")\n</pre> # plot the Computational Accuracy vs. Time (CAT) from rose.training import CAT_plot  fig, ax = CAT_plot(     [rk_solver_performances, llrm_solver_performances, rbm_performances[2:]],     labels=[\"Runge-Kutta [rtol, atol]\", \"Lagrange-Legendre\", \"RBM [$n_{rbm}$, $n_{eim}$]\"],     border_styles=[\":\", \"--\", \"-\"], ) ax.set_ylabel(r\"median relative error in $d \\sigma / d \\Omega$ [\\%]\", size=16) ax.set_xlabel(r\"time per sample [s]\", size=16)  ax.set_ylim(1e-10,10) ax.set_xlim(1e-3,3) plt.tight_layout() plt.savefig(\"cat_rbm_rm_rk.pdf\") <p>Great! It looks like using this Lagrange-Legendre method could save us a lot of time in training. For most purposes, $n \\sim 100$ should be good, with less than 0.1% median relative error across all samples, and a ~1-1.5 order of magnitude speed up from the Runge-Kutta solvers.</p> In\u00a0[33]: Copied! <pre># plot the Computational Accuracy vs. Time (CAT)\nfrom rose.training import CAT_plot\n\nfig, ax = CAT_plot(\n    [rk_solver_performances, llrm_solver_performances],\n    labels=[\"Runge-Kutta [rtol, atol]\", \"Lagrange-Legendre\"],\n    border_styles=[\":\", \"-\"],\n)\nax.set_ylabel(r\"median relative error in $d \\sigma / d \\Omega$ [%]\")\nax.set_ylim(1e-10,100)\nax.set_xlim(2e-3,10)\n</pre> # plot the Computational Accuracy vs. Time (CAT) from rose.training import CAT_plot  fig, ax = CAT_plot(     [rk_solver_performances, llrm_solver_performances],     labels=[\"Runge-Kutta [rtol, atol]\", \"Lagrange-Legendre\"],     border_styles=[\":\", \"-\"], ) ax.set_ylabel(r\"median relative error in $d \\sigma / d \\Omega$ [%]\") ax.set_ylim(1e-10,100) ax.set_xlim(2e-3,10) Out[33]: <pre>(0.002, 10)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/ROSE_Add_your_own_HF_solver/#adding-your-own-custom-high-fidelity-solver","title":"Adding your own custom high-fidelity solver\u00b6","text":"<p>Advanced users may want to substitute the default solvers in <code>rose</code> for their own custom ones. This tutorial will walk through that process, with scattering of 14.1 MeV neutrons on $^{27}$Al, using the Koning-Delaroche optical potential for the proton-nucleus interaction.</p> <p>We will add this solver, which uses the calculable R-matrix method on a Lagrange-Legendre mesh. In principle, this should provide a very precise solver, that is also capable of non-local and coupled-channels potentials.</p>"},{"location":"tutorials/ROSE_tutorial_0_quickstart/","title":"Quick start","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport rose\nfrom matplotlib import pyplot as plt\nfrom tqdm import tqdm\n</pre> import numpy as np import rose from matplotlib import pyplot as plt from tqdm import tqdm In\u00a0[2]: Copied! <pre>from matplotlib import colormaps as cm\nfrom matplotlib import pyplot as plt\nfrom matplotlib import rcParams\nfrom matplotlib.lines import Line2D\nfrom matplotlib.ticker import MaxNLocator, StrMethodFormatter\nfrom rose.training import multiple_formatter\n\ncolors = [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\",\n]\n\n# plt.rc(\"font\", **{\"family\": \"serif\", \"serif\": [\"Computer Modern\"]})\n# rcParams[\"text.latex.preamble\"] = (\n#     r\"\\usepackage{amssymb} \\usepackage{amsmath} \\usepackage{braket}\"\n# )\nplt.rc(\"text\", usetex=False)\n\nrcParams[\"legend.fontsize\"] = 12\nrcParams[\"font.size\"] = 12\nrcParams[\"font.weight\"] = \"normal\"\nrcParams[\"xtick.labelsize\"] = 12.0\nrcParams[\"ytick.labelsize\"] = 12.0\nrcParams[\"lines.linewidth\"] = 2.0\nrcParams[\"xtick.major.pad\"] = \"10\"\nrcParams[\"ytick.major.pad\"] = \"10\"\nrcParams[\"image.cmap\"] = \"BuPu\"\n</pre> from matplotlib import colormaps as cm from matplotlib import pyplot as plt from matplotlib import rcParams from matplotlib.lines import Line2D from matplotlib.ticker import MaxNLocator, StrMethodFormatter from rose.training import multiple_formatter  colors = [     \"#1f77b4\",     \"#ff7f0e\",     \"#2ca02c\",     \"#d62728\",     \"#9467bd\",     \"#8c564b\",     \"#e377c2\",     \"#7f7f7f\",     \"#bcbd22\",     \"#17becf\", ]  # plt.rc(\"font\", **{\"family\": \"serif\", \"serif\": [\"Computer Modern\"]}) # rcParams[\"text.latex.preamble\"] = ( #     r\"\\usepackage{amssymb} \\usepackage{amsmath} \\usepackage{braket}\" # ) plt.rc(\"text\", usetex=False)  rcParams[\"legend.fontsize\"] = 12 rcParams[\"font.size\"] = 12 rcParams[\"font.weight\"] = \"normal\" rcParams[\"xtick.labelsize\"] = 12.0 rcParams[\"ytick.labelsize\"] = 12.0 rcParams[\"lines.linewidth\"] = 2.0 rcParams[\"xtick.major.pad\"] = \"10\" rcParams[\"ytick.major.pad\"] = \"10\" rcParams[\"image.cmap\"] = \"BuPu\" In\u00a0[3]: Copied! <pre># set up kinematics\nfrom rose.koning_delaroche import KDGlobal, Projectile\n\n# target projectile system\nAl27 = (27, 13)\nproton = (1,1)\n\n# lab bombarding energy\nE_lab = 28  # MeV\n\n# get kinematics and default KD params\nmu, E_com, k, eta = rose.utility.kinematics(Al27, proton, E_lab=E_lab)\nomp = rose.koning_delaroche.KDGlobal(Projectile.proton)\nR_C, parameters = omp.get_params(*Al27, mu, E_com, k)\n</pre> # set up kinematics from rose.koning_delaroche import KDGlobal, Projectile  # target projectile system Al27 = (27, 13) proton = (1,1)  # lab bombarding energy E_lab = 28  # MeV  # get kinematics and default KD params mu, E_com, k, eta = rose.utility.kinematics(Al27, proton, E_lab=E_lab) omp = rose.koning_delaroche.KDGlobal(Projectile.proton) R_C, parameters = omp.get_params(*Al27, mu, E_com, k) In\u00a0[4]: Copied! <pre># take train and test parameter samples from a box bounded\n# 50% above and below the default values\nscale = 0.25\n\nbounds = np.array(\n    [\n        parameters - np.fabs(scale * parameters),\n        parameters + np.fabs(scale * parameters),\n    ]\n).T\n</pre> # take train and test parameter samples from a box bounded # 50% above and below the default values scale = 0.25  bounds = np.array(     [         parameters - np.fabs(scale * parameters),         parameters + np.fabs(scale * parameters),     ] ).T In\u00a0[5]: Copied! <pre>from rose.training import sample_params_LHC\n\n# sample points for a train/test split\n# sample from +/-50% around the default params using Latin hypercube\nn_test = 20\nn_train = 80\ntrain = sample_params_LHC(n_train, parameters, scale, seed=13)\ntest = sample_params_LHC(n_test, parameters, scale, seed=721)\n</pre> from rose.training import sample_params_LHC  # sample points for a train/test split # sample from +/-50% around the default params using Latin hypercube n_test = 20 n_train = 80 train = sample_params_LHC(n_train, parameters, scale, seed=13) test = sample_params_LHC(n_test, parameters, scale, seed=721) <p>Instantiate the set of interactions for each partial wave. We use the type <code>InteractionEIMSpace</code> because we will use the Empirical Interpolation Method (EIM) to handle potentials that are non-affine (like the Woods-Saxon forms in Koning-Delaroche). We will not discuss this here, for more detail, see the following tutorials.</p> In\u00a0[6]: Copied! <pre>interactions = rose.InteractionEIMSpace(\n    coordinate_space_potential=rose.koning_delaroche.KD_simple,\n    n_theta=len(parameters),\n    mu=mu,\n    energy=E_com,\n    is_complex=True,\n    spin_orbit_term=rose.koning_delaroche.KD_simple_so,\n    training_info=bounds,\n    Z_1=1,\n    Z_2=13,\n    R_C=R_C,\n    n_basis=20,  # we will choose 20 basis elements out of a hat for now\n)\n</pre> interactions = rose.InteractionEIMSpace(     coordinate_space_potential=rose.koning_delaroche.KD_simple,     n_theta=len(parameters),     mu=mu,     energy=E_com,     is_complex=True,     spin_orbit_term=rose.koning_delaroche.KD_simple_so,     training_info=bounds,     Z_1=1,     Z_2=13,     R_C=R_C,     n_basis=20,  # we will choose 20 basis elements out of a hat for now ) <p>Now that we have our <code>InteractionSpace</code> set up, we can construct a <code>ScatteringAmplitudeEmulator</code>, which trains and runs the emulator for us. We will pass in our set of training points and our angular mesh, and choose a number of basis elements that is the dimension of our reduced basis. In general, this number should be much smaller than the number of training points; increasing it will lead to a more accurate, albeit slower, emulator. In the following tutorial, we will optimize this, amongst other, parameters, to achieve a given accuracy and speedup goal. For now, however, we will choose an ad-hoc basis size of 10, which, it will turn out, will give us a very accurate and fast emulator.</p> In\u00a0[7]: Copied! <pre># set up and train emulator using sensible defaults\nbase_solver = rose.SchroedingerEquation.make_base_solver(\n    s_0=6 * np.pi, rk_tols=[1e-10, 1e-10], domain=np.array([0.01, 8 * np.pi])\n)\nemulator = rose.ScatteringAmplitudeEmulator.from_train(\n    interactions,\n    train,\n    n_basis=15,  # we will just choose 15 out of a hat for now, more on this later\n    angles=np.linspace(np.pi / 181, np.pi, 180),\n    base_solver=base_solver,\n    scale=True,\n    use_svd=True,\n)\n</pre> # set up and train emulator using sensible defaults base_solver = rose.SchroedingerEquation.make_base_solver(     s_0=6 * np.pi, rk_tols=[1e-10, 1e-10], domain=np.array([0.01, 8 * np.pi]) ) emulator = rose.ScatteringAmplitudeEmulator.from_train(     interactions,     train,     n_basis=15,  # we will just choose 15 out of a hat for now, more on this later     angles=np.linspace(np.pi / 181, np.pi, 180),     base_solver=base_solver,     scale=True,     use_svd=True, ) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 16/16 [03:03&lt;00:00, 11.49s/it]\n</pre> <p>It's as simple as that, now we have a trained emulator we can use to calculate cross sectons! Let's compare observables between the emulator and the high-fidelity solver using our test set of sampled parameters. We will do this by calling the functions <code>emulate_xs</code> and <code>exact_xs</code> on our emulator, passing in a set of parameters from our test set.</p> In\u00a0[8]: Copied! <pre>%%time\n\n# run high-fidelity solver\nHIFI_xs = []\nfor sample in tqdm(test):\n    HIFI_xs.append(emulator.exact_xs(sample))\n</pre> %%time  # run high-fidelity solver HIFI_xs = [] for sample in tqdm(test):     HIFI_xs.append(emulator.exact_xs(sample)) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 20/20 [00:37&lt;00:00,  1.85s/it]</pre> <pre>CPU times: user 37.3 s, sys: 117 ms, total: 37.5 s\nWall time: 37 s\n</pre> <pre>\n</pre> In\u00a0[9]: Copied! <pre>%%time\n\n# run emulator\nemu_xs = []\nfor sample in tqdm(test):\n    emu_xs.append(emulator.emulate_xs(sample))\n</pre> %%time  # run emulator emu_xs = [] for sample in tqdm(test):     emu_xs.append(emulator.emulate_xs(sample)) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 20/20 [00:00&lt;00:00, 331.64it/s]</pre> <pre>CPU times: user 60 ms, sys: 3.01 ms, total: 63 ms\nWall time: 62.7 ms\n</pre> <pre>\n</pre> <p>Now let's plot the results!</p> In\u00a0[10]: Copied! <pre>from matplotlib.lines import Line2D\n\nfig, ax = plt.subplots(figsize=(6, 4), dpi=300)\nfig.patch.set_facecolor(\"white\")\n\nfor i, sample in enumerate(test[::2]):\n    x = emulator.angles\n\n    # HIFI\n    y_exact = HIFI_xs[i].dsdo\n\n    # emulated\n    y_emu = emu_xs[i].dsdo\n\n    p = ax.plot(x, y_emu, \":\", alpha=0.5)\n    ax.plot(x, y_exact, color=p[0].get_color(), alpha=0.5)\n\nlegend_styles = [\n    Line2D([0], [0], color=\"k\", linestyle=\"--\", alpha=0.5),\n    Line2D([0], [0], color=\"k\", alpha=0.5),\n]\nax.legend(legend_styles, [\"RBM\", \"Runge-Kutta\"])\nax.set_yscale(\"log\")\nplt.xlabel(r\"$\\theta$ [radians]\", fontsize=12)\nax.xaxis.set_major_locator(plt.MultipleLocator(np.pi / 6))\nax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=6)))\n\nplt.ylabel(r\"$\\sigma / \\sigma_{\\rm{Rutherford}}$ \", fontsize=12)\n</pre> from matplotlib.lines import Line2D  fig, ax = plt.subplots(figsize=(6, 4), dpi=300) fig.patch.set_facecolor(\"white\")  for i, sample in enumerate(test[::2]):     x = emulator.angles      # HIFI     y_exact = HIFI_xs[i].dsdo      # emulated     y_emu = emu_xs[i].dsdo      p = ax.plot(x, y_emu, \":\", alpha=0.5)     ax.plot(x, y_exact, color=p[0].get_color(), alpha=0.5)  legend_styles = [     Line2D([0], [0], color=\"k\", linestyle=\"--\", alpha=0.5),     Line2D([0], [0], color=\"k\", alpha=0.5), ] ax.legend(legend_styles, [\"RBM\", \"Runge-Kutta\"]) ax.set_yscale(\"log\") plt.xlabel(r\"$\\theta$ [radians]\", fontsize=12) ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi / 6)) ax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=6)))  plt.ylabel(r\"$\\sigma / \\sigma_{\\rm{Rutherford}}$ \", fontsize=12) Out[10]: <pre>Text(0, 0.5, '$\\\\sigma / \\\\sigma_{\\\\rm{Rutherford}}$ ')</pre> In\u00a0[11]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 4), dpi=300)\nfig.patch.set_facecolor(\"white\")\n\nfor i, sample in enumerate(test[::2]):\n    x = emulator.angles\n\n    # HIFI\n    y_exact = HIFI_xs[i].Ay\n\n    # emulated\n    y_emu = emu_xs[i].Ay\n\n    p = ax.plot(x, y_emu, \":\", alpha=0.5)\n    ax.plot(x, y_exact, color=p[0].get_color(), alpha=0.5)\n\nlegend_styles = [\n    Line2D([0], [0], color=\"k\", linestyle=\"--\", alpha=0.5),\n    Line2D([0], [0], color=\"k\", alpha=0.5),\n]\nax.legend(legend_styles, [\"RBM\", \"Runge-Kutta\"])\nax.set_ylim([-1, 1])\nplt.xlabel(r\"$\\theta$ [radians]\", fontsize=12)\nax.xaxis.set_major_locator(plt.MultipleLocator(np.pi / 6))\nax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=6)))\n\nplt.ylabel(r\"$A_y(\\theta)$ \", fontsize=12)\n</pre> fig, ax = plt.subplots(figsize=(6, 4), dpi=300) fig.patch.set_facecolor(\"white\")  for i, sample in enumerate(test[::2]):     x = emulator.angles      # HIFI     y_exact = HIFI_xs[i].Ay      # emulated     y_emu = emu_xs[i].Ay      p = ax.plot(x, y_emu, \":\", alpha=0.5)     ax.plot(x, y_exact, color=p[0].get_color(), alpha=0.5)  legend_styles = [     Line2D([0], [0], color=\"k\", linestyle=\"--\", alpha=0.5),     Line2D([0], [0], color=\"k\", alpha=0.5), ] ax.legend(legend_styles, [\"RBM\", \"Runge-Kutta\"]) ax.set_ylim([-1, 1]) plt.xlabel(r\"$\\theta$ [radians]\", fontsize=12) ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi / 6)) ax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=6)))  plt.ylabel(r\"$A_y(\\theta)$ \", fontsize=12) Out[11]: <pre>Text(0, 0.5, '$A_y(\\\\theta)$ ')</pre> <p>Isn't that nice, the emulated and high-fidelity observables are right on top of eachother! The following series of tutorials will walk through how to choose the the optimal hyper-parameters (like the basis size), and demonstrate linking to <code>surmise</code> for fast Bayesian uncertainty quantification!</p>"},{"location":"tutorials/ROSE_tutorial_0_quickstart/#quick-start","title":"Quick start\u00b6","text":"<p>Let's set up a simple emulator for scattering of 28 MeV protons on $^{27}$Al, using the Koning-Delaroche optical potential for the proton-nucleus interaction.</p>"},{"location":"tutorials/ROSE_tutorial_1_building_an_emulator/","title":"Building and Optimizing an Emulator","text":"In\u00a0[1]: Copied! <pre># (if you don't have it already)\n#!pip install nuclear-rose\n\nimport rose\nfrom numba import njit  # we need to this to Just-In-Time (JIT) compile our interaction\n\n# other nice things\nimport numpy as np\nimport time\nimport os\nfrom scipy.stats import qmc\n\n# import stuff for nice plotting\nimport matplotlib.pyplot as plt\nfrom matplotlib.lines import Line2D\nimport scipy.stats as sps\nfrom tqdm import tqdm\nimport random\nimport datetime\n\nprint(rose.__version__)\n</pre> # (if you don't have it already) #!pip install nuclear-rose  import rose from numba import njit  # we need to this to Just-In-Time (JIT) compile our interaction  # other nice things import numpy as np import time import os from scipy.stats import qmc  # import stuff for nice plotting import matplotlib.pyplot as plt from matplotlib.lines import Line2D import scipy.stats as sps from tqdm import tqdm import random import datetime  print(rose.__version__) <pre>1.1.3\n</pre> In\u00a0[2]: Copied! <pre>from matplotlib.ticker import StrMethodFormatter\nfrom matplotlib.lines import Line2D\nfrom matplotlib.ticker import MaxNLocator\nfrom matplotlib import pyplot as plt\nfrom matplotlib import rcParams\nfrom rose.training import multiple_formatter\n\ncolors = [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\",\n]\n\n# plt.rc(\"font\", **{\"family\": \"serif\", \"serif\": [\"Computer Modern\"]})\n# rcParams[\n#     \"text.latex.preamble\"\n# ] = r\"\\usepackage{amssymb} \\usepackage{amsmath} \\usepackage{braket}\"\nplt.rc(\"text\", usetex=False)\n\nrcParams[\"legend.fontsize\"] = 12\nrcParams[\"font.size\"] = 12\nrcParams[\"font.weight\"] = \"normal\"\nrcParams[\"xtick.labelsize\"] = 12.0\nrcParams[\"ytick.labelsize\"] = 12.0\nrcParams[\"lines.linewidth\"] = 2.0\nrcParams[\"xtick.major.pad\"] = \"10\"\nrcParams[\"ytick.major.pad\"] = \"10\"\nrcParams[\"image.cmap\"] = \"BuPu\"\n</pre> from matplotlib.ticker import StrMethodFormatter from matplotlib.lines import Line2D from matplotlib.ticker import MaxNLocator from matplotlib import pyplot as plt from matplotlib import rcParams from rose.training import multiple_formatter  colors = [     \"#1f77b4\",     \"#ff7f0e\",     \"#2ca02c\",     \"#d62728\",     \"#9467bd\",     \"#8c564b\",     \"#e377c2\",     \"#7f7f7f\",     \"#bcbd22\",     \"#17becf\", ]  # plt.rc(\"font\", **{\"family\": \"serif\", \"serif\": [\"Computer Modern\"]}) # rcParams[ #     \"text.latex.preamble\" # ] = r\"\\usepackage{amssymb} \\usepackage{amsmath} \\usepackage{braket}\" plt.rc(\"text\", usetex=False)  rcParams[\"legend.fontsize\"] = 12 rcParams[\"font.size\"] = 12 rcParams[\"font.weight\"] = \"normal\" rcParams[\"xtick.labelsize\"] = 12.0 rcParams[\"ytick.labelsize\"] = 12.0 rcParams[\"lines.linewidth\"] = 2.0 rcParams[\"xtick.major.pad\"] = \"10\" rcParams[\"ytick.major.pad\"] = \"10\" rcParams[\"image.cmap\"] = \"BuPu\" In\u00a0[3]: Copied! <pre>Starting_time=time.time()\n</pre> Starting_time=time.time() In\u00a0[4]: Copied! <pre># targets and projectiles defined by (A,Z)\nCa40 = (40, 20)\nproton = (1,1)\n\n# set up kinematics\nE_lab = 14.1  # MeV - like from a DT generator\nmu, E_com, k, eta = rose.kinematics(target=Ca40, projectile=proton, E_lab=E_lab)\n\n# domain of the differential cross section; the observable we want to emulate\n# we will evaluate the accuracy of our emulator by comparing dsigma/dtheta on this domain\nangles = np.linspace(1, 179, 200) * np.pi / 180\n</pre> # targets and projectiles defined by (A,Z) Ca40 = (40, 20) proton = (1,1)  # set up kinematics E_lab = 14.1  # MeV - like from a DT generator mu, E_com, k, eta = rose.kinematics(target=Ca40, projectile=proton, E_lab=E_lab)  # domain of the differential cross section; the observable we want to emulate # we will evaluate the accuracy of our emulator by comparing dsigma/dtheta on this domain angles = np.linspace(1, 179, 200) * np.pi / 180 In\u00a0[5]: Copied! <pre>from rose.utility import woods_saxon, woods_saxon_prime\n\n\n# total potential with a real and central term (with the same geometry)\n# and imaginary surface-peaked term, but no SO coupling\n@njit\ndef optical_potential(r, theta):\n    Vv, Wv, Wd, Vso, Wso, Rv, Rd, Rso, av, ad, aso = theta\n    return (1j * Wv - Vv) * woods_saxon(r, Rv, av) - (4j * ad * Wd) * woods_saxon_prime(\n        r, Rd, ad\n    )\n\n\n# spin orbit interaction constant\nmso = 1.0 / rose.constants.MASS_PION\n\n\n# spin-orbit (SO) coulpling term - a function of l dot s, l being the orbital angular momentum\n# and s being the spin of the neutron\n@njit\ndef spin_orbit_potential(r, theta, ldots):\n    Vv, Wv, Wd, Vso, Wso, Rv, Rd, Rso, av, ad, aso = theta\n    return (Vso + 1j * Wso) * mso**2 * ldots * woods_saxon_prime(r, Rso, aso) / r\n\n\n# the total number of parameters\nnparams = 11\n</pre> from rose.utility import woods_saxon, woods_saxon_prime   # total potential with a real and central term (with the same geometry) # and imaginary surface-peaked term, but no SO coupling @njit def optical_potential(r, theta):     Vv, Wv, Wd, Vso, Wso, Rv, Rd, Rso, av, ad, aso = theta     return (1j * Wv - Vv) * woods_saxon(r, Rv, av) - (4j * ad * Wd) * woods_saxon_prime(         r, Rd, ad     )   # spin orbit interaction constant mso = 1.0 / rose.constants.MASS_PION   # spin-orbit (SO) coulpling term - a function of l dot s, l being the orbital angular momentum # and s being the spin of the neutron @njit def spin_orbit_potential(r, theta, ldots):     Vv, Wv, Wd, Vso, Wso, Rv, Rd, Rso, av, ad, aso = theta     return (Vso + 1j * Wso) * mso**2 * ldots * woods_saxon_prime(r, Rso, aso) / r   # the total number of parameters nparams = 11 In\u00a0[6]: Copied! <pre># the default parameters determined by Koning &amp; Delaroche\nVvKD = 46.7238\nWvKD = 1.72334\nWdKD = -7.2357\nVsoKD = 6.1\nWsoKD = -3.1\n\nRvKD = 4.0538\nRdKD = 4.4055\nRsoKD = 1.01 * 40 ** (1.0 / 3.0)\n\navKD = 0.6718\nadKD = 0.5379\nasoKD = 0.60\n\n# This is the value of the parameters coming from the Koning-Delaroche parametrization.\n# Taken from https://www-nds.iaea.org/RIPL-3/\nalpha_central = np.array(\n    [VvKD, WvKD, WdKD, VsoKD, WsoKD, RvKD, RdKD, RsoKD, avKD, adKD, asoKD]\n)\n</pre> # the default parameters determined by Koning &amp; Delaroche VvKD = 46.7238 WvKD = 1.72334 WdKD = -7.2357 VsoKD = 6.1 WsoKD = -3.1  RvKD = 4.0538 RdKD = 4.4055 RsoKD = 1.01 * 40 ** (1.0 / 3.0)  avKD = 0.6718 adKD = 0.5379 asoKD = 0.60  # This is the value of the parameters coming from the Koning-Delaroche parametrization. # Taken from https://www-nds.iaea.org/RIPL-3/ alpha_central = np.array(     [VvKD, WvKD, WdKD, VsoKD, WsoKD, RvKD, RdKD, RsoKD, avKD, adKD, asoKD] ) In\u00a0[7]: Copied! <pre>scale_training = 0.2\nbounds = np.array(\n    [\n        alpha_central - np.fabs(alpha_central * scale_training),\n        alpha_central + np.fabs(alpha_central * scale_training),\n    ]\n).T\n</pre> scale_training = 0.2 bounds = np.array(     [         alpha_central - np.fabs(alpha_central * scale_training),         alpha_central + np.fabs(alpha_central * scale_training),     ] ).T In\u00a0[8]: Copied! <pre>from rose.training import sample_params_LHC  # Latin Hypercube sampling\n\n#  train/test split\nn_test = 20\nn_train = 80\n\nseed_train = 13\nseed_test = 14\n\ntraining_samples = sample_params_LHC(\n    n_train, alpha_central, scale=scale_training, seed=seed_train\n)\ntest_samples = sample_params_LHC(\n    n_test, alpha_central, scale=scale_training, seed=seed_test\n)\n</pre> from rose.training import sample_params_LHC  # Latin Hypercube sampling  #  train/test split n_test = 20 n_train = 80  seed_train = 13 seed_test = 14  training_samples = sample_params_LHC(     n_train, alpha_central, scale=scale_training, seed=seed_train ) test_samples = sample_params_LHC(     n_test, alpha_central, scale=scale_training, seed=seed_test ) In\u00a0[9]: Copied! <pre># Finally, we can invoke ROSE. Let's build an InteractionEIMSpace, running over lmax partial\n# waves, with the optical potential we defined above.\ninteractions = rose.InteractionEIMSpace(\n    coordinate_space_potential=optical_potential,\n    n_theta=nparams,\n    mu=mu,\n    energy=E_com,\n    is_complex=True,\n    spin_orbit_term=spin_orbit_potential,\n    training_info=bounds,\n)\n# that was easy!\n</pre> # Finally, we can invoke ROSE. Let's build an InteractionEIMSpace, running over lmax partial # waves, with the optical potential we defined above. interactions = rose.InteractionEIMSpace(     coordinate_space_potential=optical_potential,     n_theta=nparams,     mu=mu,     energy=E_com,     is_complex=True,     spin_orbit_term=spin_orbit_potential,     training_info=bounds, ) # that was easy! <p>Now that we have our interaction, let's set up 1) a HF solver and 2) an emulator. In ROSE, these tasks are handled by the same object; <code>ScatteringAmplitudeEmulator</code>. We will set one up, and calculate snapshots of the cross sections at our test points.</p> In\u00a0[10]: Copied! <pre># let's build our first reduced basis emulator\nbase_solver = rose.SchroedingerEquation.make_base_solver(\n    s_0=6 * np.pi, rk_tols=[1e-10, 1e-10], domain=np.array([1e-8, 8 * np.pi])\n)\nemulator = rose.ScatteringAmplitudeEmulator.from_train(\n    interactions,\n    training_samples,\n    base_solver=base_solver,\n    n_basis=5,\n    angles=angles,\n    scale=True,\n    use_svd=True,\n)\n</pre> # let's build our first reduced basis emulator base_solver = rose.SchroedingerEquation.make_base_solver(     s_0=6 * np.pi, rk_tols=[1e-10, 1e-10], domain=np.array([1e-8, 8 * np.pi]) ) emulator = rose.ScatteringAmplitudeEmulator.from_train(     interactions,     training_samples,     base_solver=base_solver,     n_basis=5,     angles=angles,     scale=True,     use_svd=True, ) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 16/16 [01:22&lt;00:00,  5.18s/it]\n</pre> <p>Great, now let's compare some exact and emulated differential cross sections!</p> In\u00a0[11]: Copied! <pre>%%time\n# calculate the \"ground truth\" (high fidelity) differential cross section \n# for the 50 test parameters we sampled\nground_truth_xs = []\nfor params in tqdm(test_samples):\n    ground_truth_xs.append(emulator.exact_xs(params).dsdo)\n</pre> %%time # calculate the \"ground truth\" (high fidelity) differential cross section  # for the 50 test parameters we sampled ground_truth_xs = [] for params in tqdm(test_samples):     ground_truth_xs.append(emulator.exact_xs(params).dsdo) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 20/20 [00:15&lt;00:00,  1.28it/s]</pre> <pre>CPU times: total: 3.36 s\nWall time: 15.7 s\n</pre> <pre>\n</pre> <p>Great, we have our ground truth test cross section! Now let's reproduce them with our emulator.</p> In\u00a0[12]: Copied! <pre>%%time\n# calculate the emulated differential cross section for the 50 test parameters we sampled\nemulated_xs = []\nfor params in tqdm(test_samples):\n    emulated_xs.append(emulator.emulate_xs(params).dsdo)\n</pre> %%time # calculate the emulated differential cross section for the 50 test parameters we sampled emulated_xs = [] for params in tqdm(test_samples):     emulated_xs.append(emulator.emulate_xs(params).dsdo) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 20/20 [00:00&lt;00:00, 1665.23it/s]</pre> <pre>CPU times: total: 0 ns\nWall time: 13 ms\n</pre> <pre>\n</pre> <p>Notice how much faster that was. Let's plot the results to see how we did:</p> In\u00a0[13]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 4), dpi=300)\nfig.patch.set_facecolor(\"white\")\n\nfor i in range(5):\n    p = ax.plot(angles, ground_truth_xs[i], alpha=0.5)\n    ax.plot(\n        angles, emulated_xs[i], linestyle=\"dashed\", color=p[0].get_color(), alpha=0.5\n    )\n\nlegend_styles = [\n    Line2D([0], [0], color=\"k\", linestyle=\"--\"),\n    Line2D([0], [0], color=\"k\"),\n]\nax.xaxis.set_major_locator(plt.MultipleLocator(np.pi/6))\nax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=6)))\n\nax.legend(legend_styles, [\"RBM\", \"Runge-Kutta\"])\nax.set_yscale(\"log\")\nplt.xlabel(r\"$\\theta$ [radians]\")\nplt.ylabel(r\"$\\frac{d \\sigma}{d \\Omega}$ [mb/sr]\")\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(6, 4), dpi=300) fig.patch.set_facecolor(\"white\")  for i in range(5):     p = ax.plot(angles, ground_truth_xs[i], alpha=0.5)     ax.plot(         angles, emulated_xs[i], linestyle=\"dashed\", color=p[0].get_color(), alpha=0.5     )  legend_styles = [     Line2D([0], [0], color=\"k\", linestyle=\"--\"),     Line2D([0], [0], color=\"k\"), ] ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi/6)) ax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=6)))  ax.legend(legend_styles, [\"RBM\", \"Runge-Kutta\"]) ax.set_yscale(\"log\") plt.xlabel(r\"$\\theta$ [radians]\") plt.ylabel(r\"$\\frac{d \\sigma}{d \\Omega}$ [mb/sr]\") plt.show() <p>This is not bad, but we can do better by optimizing the hyperparameters a bit. Many computational methods have one or more handles to trade off better accuracy at the cost of loss of speed. In the case of the reduced basis emulator we can directly change 1) the size of the reduced basis, and 2) the number of terms in the EIM expansion. Remember, we used 5 reduced basis elements, and 11 EIM terms.</p> <p>In <code>rose.training</code>, there are some functions that can help us test different hyperparameter configurations.</p> <p>Let's choose a few configurations for the emulator and compare them. Our metrics will be:</p> <ol> <li>time to generate solution</li> <li>accuracy of solution (relative to the HF solver with a very small tolerance)</li> </ol> <p>For each of the configs we run, we will set up the emulator, and calculate these 2 metrics. First, we will do the offline training for all the emulator configs. This is where most of the computational expense of an emulator comes in; training in the offline stage. Once each partial wave, at each paramater sample point, has it's reduced basis trained, the online stage, where we calculate observables, should be much faster.</p> In\u00a0[\u00a0]: Copied! <pre>#[basis size, number of terms in EIM decomposition]\nsae_configs = [(5, 5), (10, 10), (15, 15), (20, 20)]\n_, emulators = rose.training.build_sae_config_set(\n    sae_configs,\n    interactions,\n    training_samples,\n    bounds,\n    angles=angles,\n    base_solver=base_solver\n)\n</pre> #[basis size, number of terms in EIM decomposition] sae_configs = [(5, 5), (10, 10), (15, 15), (20, 20)] _, emulators = rose.training.build_sae_config_set(     sae_configs,     interactions,     training_samples,     bounds,     angles=angles,     base_solver=base_solver ) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 16/16 [01:20&lt;00:00,  5.04s/it]\n 25%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                                             | 1/4 [00:44&lt;02:13, 44.53s/it]</pre> <p>We will use the handy class <code>CATPerformance</code> to time and store the outputs and residuals of each of our emulators. We will write these objects to disk, so that we can read them later if we want to.</p> In\u00a0[\u00a0]: Copied! <pre>from rose.training import CATPerformance\nimport pickle\nfrom pathlib import Path\n</pre> from rose.training import CATPerformance import pickle from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>%%time\nrbm_performances = []\nfor solver, config in zip(emulators, sae_configs):\n    label = r\"$\\left({:d} , {:d}\\right)$\".format(*config)\n    fpath = Path(\"perf_rbm_{:d}_{:d}.pkl\".format(*config))\n    if fpath.is_file():\n        with open(fpath, \"rb\") as f:\n            perf = pickle.load(f)\n            rbm_performances.append(perf)\n    else:\n        rbm_performances.append(\n            CATPerformance(\n                benchmark_runner=lambda sample: solver.emulate_xs(sample).dsdo,\n                benchmark_inputs=test_samples,\n                benchmark_ground_truth=ground_truth_xs,\n                label=label,\n                n_timing=10,\n            )\n        )\n        with open(fpath, \"wb\") as f:\n            pickle.dump(rbm_performances[-1], f)\n</pre> %%time rbm_performances = [] for solver, config in zip(emulators, sae_configs):     label = r\"$\\left({:d} , {:d}\\right)$\".format(*config)     fpath = Path(\"perf_rbm_{:d}_{:d}.pkl\".format(*config))     if fpath.is_file():         with open(fpath, \"rb\") as f:             perf = pickle.load(f)             rbm_performances.append(perf)     else:         rbm_performances.append(             CATPerformance(                 benchmark_runner=lambda sample: solver.emulate_xs(sample).dsdo,                 benchmark_inputs=test_samples,                 benchmark_ground_truth=ground_truth_xs,                 label=label,                 n_timing=10,             )         )         with open(fpath, \"wb\") as f:             pickle.dump(rbm_performances[-1], f) <p>We would like to compare the results of our emulartors to HF solvers at a variety of tolerances, to make sure using an emulator is actually worthwhile, as opposed to just cranking down the tolerances on our HF solver. To do that, we'll use <code>ScatteringAmplitudeEmulators.HIFI_solver</code> to set up just the high-fidelity solver without wasting time training.</p> In\u00a0[\u00a0]: Copied! <pre># log of tolerance for each hifi solver\nrk_logtol = [-5, -6, -7]\nhifi_solvers = []\nfor tols in rk_logtol:\n    hf_tols = [10 ** (tols), 10 ** (tols)]\n    solver = rose.SchroedingerEquation(None, hf_tols)\n    hifi_solvers.append(\n        rose.ScatteringAmplitudeEmulator.HIFI_solver(\n            interactions,\n            solver,\n            angles=angles,\n        )\n    )\n</pre> # log of tolerance for each hifi solver rk_logtol = [-5, -6, -7] hifi_solvers = [] for tols in rk_logtol:     hf_tols = [10 ** (tols), 10 ** (tols)]     solver = rose.SchroedingerEquation(None, hf_tols)     hifi_solvers.append(         rose.ScatteringAmplitudeEmulator.HIFI_solver(             interactions,             solver,             angles=angles,         )     ) <p>And now we do the same with <code>CATPerformance</code> for this set of hifi solvers:</p> In\u00a0[\u00a0]: Copied! <pre>%%time\nhifi_solver_performances = []\nfor solver, tols in zip(hifi_solvers, rk_logtol):\n    label = r\"$\\left[{:1.0e} , {:1.0e}\\right]$\".format(10**tols, 10**tols)\n    fpath = Path(\"perf_hifi_{:1.0e}_{:1.0e}.pkl\".format(10**tols, 10**tols))\n    if fpath.is_file():\n        with open(fpath, \"rb\") as f:\n            perf = pickle.load(f)\n            hifi_solver_performances.append(perf)\n    else:\n        hifi_solver_performances.append(\n            CATPerformance(\n                benchmark_runner=lambda sample: solver.exact_xs(sample).dsdo,\n                benchmark_inputs=test_samples,\n                benchmark_ground_truth=ground_truth_xs,\n                label=label,\n                n_timing=1,\n            )\n        )\n        with open(fpath, \"wb\") as f:\n            pickle.dump(hifi_solver_performances[-1], f)\n</pre> %%time hifi_solver_performances = [] for solver, tols in zip(hifi_solvers, rk_logtol):     label = r\"$\\left[{:1.0e} , {:1.0e}\\right]$\".format(10**tols, 10**tols)     fpath = Path(\"perf_hifi_{:1.0e}_{:1.0e}.pkl\".format(10**tols, 10**tols))     if fpath.is_file():         with open(fpath, \"rb\") as f:             perf = pickle.load(f)             hifi_solver_performances.append(perf)     else:         hifi_solver_performances.append(             CATPerformance(                 benchmark_runner=lambda sample: solver.exact_xs(sample).dsdo,                 benchmark_inputs=test_samples,                 benchmark_ground_truth=ground_truth_xs,                 label=label,                 n_timing=1,             )         )         with open(fpath, \"wb\") as f:             pickle.dump(hifi_solver_performances[-1], f) <p>Finally, let's plot the results to see how our emulators do:</p> In\u00a0[\u00a0]: Copied! <pre># plot the Computational Accuracy vs. Time (CAT)\nfrom rose.training import CAT_plot\n\nfig, ax = CAT_plot(\n    [rbm_performances, hifi_solver_performances],\n    labels=[\"RBM [$n_{rbm}$, $n_{eim}$]\", \"Runge-Kutta [rtol, atol]\"],\n    border_styles=[\":\", \"-\"],\n)\nax.set_ylabel(r\"median relative error in $d \\sigma / d \\Omega$ [\\%]\", fontsize=12)\nplt.ylim(1e-4, 100)\nplt.xlim(5e-4, 10)\n</pre> # plot the Computational Accuracy vs. Time (CAT) from rose.training import CAT_plot  fig, ax = CAT_plot(     [rbm_performances, hifi_solver_performances],     labels=[\"RBM [$n_{rbm}$, $n_{eim}$]\", \"Runge-Kutta [rtol, atol]\"],     border_styles=[\":\", \"-\"], ) ax.set_ylabel(r\"median relative error in $d \\sigma / d \\Omega$ [\\%]\", fontsize=12) plt.ylim(1e-4, 100) plt.xlim(5e-4, 10) <p>Well how about that! No matter how you crank the hifi tolerances, you just can't beat the RBM in time and accuracy.</p> <p>Now we can decide empirically which emulator configuration is the fastest for a given accuracy, and we can quantitatively see that the emulators are categorically superior to the HF solver when it comes to getting fast and accurate differential cross sections.</p> <p>Notice, increasing the number of EIM terms can increase accuracy without making too much large impact on time. We would expect diminishing returns for more EIM terms, however, and if the error is dominated by too small of a basis (e.g. the case of the (3,5) emulator) then increasing the EIM terms will not improve the emulator at all. For basis size, since <code>rose</code> has to actually solve a system of equations proportional to this variable, we except the time to scale roughly with the square of the basis size, so the impact on time is much larger. Since we only trained with 50 samples, in this case increasing the basis number further will saturate the median error in around 10^-4, but further improvement can be done by providing more training points.</p> In\u00a0[\u00a0]: Copied! <pre>fig, ax = plt.subplots(figsize=(6, 4), dpi=300)\nfig.patch.set_facecolor(\"white\")\n\nperf_2_plot = rbm_performances[-1]\n\nfor i in range(int(n_test/2)):\n    p = ax.plot(angles, ground_truth_xs[i], alpha=0.5)\n    ax.plot(angles, \n            perf_2_plot.runner_output[i,...], \n            linestyle= \":\",\n            color=p[0].get_color(), \n           # alpha=0.5\n           )\n\nlegend_styles = [\n    Line2D([0], [0], color=\"k\", linestyle=\"--\"),\n    Line2D([0], [0], color=\"k\"),\n]\nax.xaxis.set_major_locator(plt.MultipleLocator(np.pi/6))\nax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=6)))\n\nax.legend(legend_styles, [f\"RBM {perf_2_plot.label}\", \"Runge-Kutta\"])\nax.set_yscale(\"log\")\nplt.xlabel(r\"$\\theta$ [radians]\")\nplt.ylabel(r\"$\\frac{d \\sigma}{d \\Omega}$ [mb/sr]\")\n</pre> fig, ax = plt.subplots(figsize=(6, 4), dpi=300) fig.patch.set_facecolor(\"white\")  perf_2_plot = rbm_performances[-1]  for i in range(int(n_test/2)):     p = ax.plot(angles, ground_truth_xs[i], alpha=0.5)     ax.plot(angles,              perf_2_plot.runner_output[i,...],              linestyle= \":\",             color=p[0].get_color(),             # alpha=0.5            )  legend_styles = [     Line2D([0], [0], color=\"k\", linestyle=\"--\"),     Line2D([0], [0], color=\"k\"), ] ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi/6)) ax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=6)))  ax.legend(legend_styles, [f\"RBM {perf_2_plot.label}\", \"Runge-Kutta\"]) ax.set_yscale(\"log\") plt.xlabel(r\"$\\theta$ [radians]\") plt.ylabel(r\"$\\frac{d \\sigma}{d \\Omega}$ [mb/sr]\") <p>We can do some spot checks to make sure our chosen emulator effectively emulates wavefunctions, phase shifts, and the potential itself with negligible loss of accuracy.</p> In\u00a0[\u00a0]: Copied! <pre>test = test_samples[0] # grab a test sample\nsae = emulators[-1] # which emulator config to test\n</pre> test = test_samples[0] # grab a test sample sae = emulators[-1] # which emulator config to test In\u00a0[\u00a0]: Copied! <pre>solutions_rk = sae.exact_wave_functions(test)\nsolutions_rbm = sae.emulate_wave_functions(test)\n# match phases\nfor l in range(len(solutions_rk)):\n    for j in range(len(solutions_rk[l])):\n        i = np.argmax(solutions_rk[l][j])\n        solutions_rbm[l][j] *= (\n            solutions_rk[l][j][i] / solutions_rbm[l][j][i])\n</pre> solutions_rk = sae.exact_wave_functions(test) solutions_rbm = sae.emulate_wave_functions(test) # match phases for l in range(len(solutions_rk)):     for j in range(len(solutions_rk[l])):         i = np.argmax(solutions_rk[l][j])         solutions_rbm[l][j] *= (             solutions_rk[l][j][i] / solutions_rbm[l][j][i]) In\u00a0[\u00a0]: Copied! <pre>from rose.training import compare_partial_waves\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 3), dpi=600)\nfig.patch.set_facecolor(\"white\")\n\ncompare_partial_waves(\n    sae.rbes[0][0].basis.rho_mesh,\n    [solutions_rk[0:3], solutions_rbm[0:3]],\n    [\"Runge-Kutta\", \"RBM\"],\n    fig,\n    ax1,\n    ax2,\n)\nplt.tight_layout()\n</pre> from rose.training import compare_partial_waves fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 3), dpi=600) fig.patch.set_facecolor(\"white\")  compare_partial_waves(     sae.rbes[0][0].basis.rho_mesh,     [solutions_rk[0:3], solutions_rbm[0:3]],     [\"Runge-Kutta\", \"RBM\"],     fig,     ax1,     ax2, ) plt.tight_layout() In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>deltas_rk = sae.exact_phase_shifts(test)\ndeltas_rbm = sae.emulate_phase_shifts(test)\n</pre> deltas_rk = sae.exact_phase_shifts(test) deltas_rbm = sae.emulate_phase_shifts(test) In\u00a0[\u00a0]: Copied! <pre>from rose.training import plot_phase_shifts, compare_phase_shifts_err\nfrom matplotlib import ticker\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(\n    2, 2, sharex=True, figsize=(8, 4), height_ratios=[1, 0.5], dpi=600\n)\nfig.patch.set_facecolor(\"white\")\n\ncompare_phase_shifts_err(\n    deltas_rk,\n    deltas_rbm,\n    \"Runge-Kutta\",\n    \"RBM\",\n    fig,\n    ax1,\n    ax2,\n    ax3,\n    ax4,\n    small_label1=\"RK\",\n    small_label2=\"RBM\",\n)\n\nplt.tight_layout()\n</pre> from rose.training import plot_phase_shifts, compare_phase_shifts_err from matplotlib import ticker  fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(     2, 2, sharex=True, figsize=(8, 4), height_ratios=[1, 0.5], dpi=600 ) fig.patch.set_facecolor(\"white\")  compare_phase_shifts_err(     deltas_rk,     deltas_rbm,     \"Runge-Kutta\",     \"RBM\",     fig,     ax1,     ax2,     ax3,     ax4,     small_label1=\"RK\",     small_label2=\"RBM\", )  plt.tight_layout() In\u00a0[\u00a0]: Copied! <pre>from matplotlib.lines import Line2D\n\nf, ax = plt.subplots(1,1, figsize=(6,4), facecolor=\"white\", dpi=600)\n\ns_mesh = sae.rbes[0][0].basis.rho_mesh\nfor sample in test_samples[::2]:\n    p = plt.plot(s_mesh, sae.rbes[0][0].interaction.tilde(s_mesh, sample), alpha=0.5)[0]\n    plt.plot(\n        s_mesh,\n        sae.rbes[0][0].interaction.tilde_emu(sample),\n        \":\",\n        alpha=0.5,\n        color=p.get_color(),\n    )\nlegend_styles = [\n    Line2D([0], [0], color=\"tab:gray\", linestyle=\":\", alpha=0.8),\n    Line2D([0], [0], color=\"tab:gray\", alpha=0.8),\n]\nleg = plt.legend(\n    legend_styles,\n    [\"EIM\", \"Exact\",],\n    loc=\"lower right\",\n)\nax.xaxis.set_major_locator(plt.MultipleLocator(np.pi/2))\nax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=2)))\nplt.ylabel(r\"$U(s; \\alpha)$\")\nplt.xlabel(r\"$s = kr$\")\nplt.xlim([0,8])\n</pre> from matplotlib.lines import Line2D  f, ax = plt.subplots(1,1, figsize=(6,4), facecolor=\"white\", dpi=600)  s_mesh = sae.rbes[0][0].basis.rho_mesh for sample in test_samples[::2]:     p = plt.plot(s_mesh, sae.rbes[0][0].interaction.tilde(s_mesh, sample), alpha=0.5)[0]     plt.plot(         s_mesh,         sae.rbes[0][0].interaction.tilde_emu(sample),         \":\",         alpha=0.5,         color=p.get_color(),     ) legend_styles = [     Line2D([0], [0], color=\"tab:gray\", linestyle=\":\", alpha=0.8),     Line2D([0], [0], color=\"tab:gray\", alpha=0.8), ] leg = plt.legend(     legend_styles,     [\"EIM\", \"Exact\",],     loc=\"lower right\", ) ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi/2)) ax.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=2))) plt.ylabel(r\"$U(s; \\alpha)$\") plt.xlabel(r\"$s = kr$\") plt.xlim([0,8]) In\u00a0[\u00a0]: Copied! <pre>Ending_time=time.time()\n\nprint(\"Total time to run the notebook (minutes):\")\n\nprint(round((Ending_time-Starting_time)/60))\n</pre> Ending_time=time.time()  print(\"Total time to run the notebook (minutes):\")  print(round((Ending_time-Starting_time)/60)) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/ROSE_tutorial_1_building_an_emulator/#building-and-optimizing-an-emulator","title":"Building and Optimizing an Emulator\u00b6","text":"<p>Let's build an emulator for a quantum scattering problem with an optical potential! In this tutorial, we will show how to write your own interaction from scratch, rather than use the built-in versions, as well as walk you through some of the ideas behind the reduced basis method. We will choose neutron scattering on the $^{40}$ Ca nucleus as our test problem. In particular, we want to build an emulator that can predict the differential elastic scattering cross section for this reaction, at a given energy as quickly and accurately as possible.</p> <p>The following form of Schrodinger equation results from choosing an optical potential, $V(r,\\alpha)=U(r,\\alpha)/2\\mu$ as the neutron-nucleus interaction potential energy, which depends on some parameters $\\alpha$, and reduced mass $mu$. We decompose the radial part of the Hamiltonian into partial waves, reduce it by dividing the wavefunction by $r$, such that $\\phi_{\\ell}(r) = r \\chi_\\ell(r)$ for a given radial wavefunction $\\chi_\\ell(r)$. We then subtract the energy, $\\hbar^2 p^2/2\\mu$, from both sides, and divide by $\\hbar^2/2\\mu$ to yield:</p> <p>\\begin{equation}     F_\\alpha(\\phi)=\\left(-\\frac{d^2}{dr^2}+\\frac{\\ell(\\ell+1)}{r^2}+U(r,\\alpha)-p^2\\right)\\phi(r)=0. \\end{equation}</p> <p>Here, $\\ell$ is the angular momentum quantum number, and $p$ is the asymptotic linear momentum. Internally within <code>rose</code>, we re-scale the equation to work in dimensionless units $s=rp$. Our reduced basis expansion of $n$ basis can be written as:</p> <p>\\begin{equation}    \\phi(r) \\approx \\phi_0(r) + \\sum_k^n a_k\\phi_k(r) \\end{equation}</p> <p>The goal of this tutorial is to demonstrate how to build such an emulator with <code>rose</code>, and then choose the optimal emulator configuration to accomplish this. The full derivation of the methodology behind <code>rose</code> is given in this paper, and explained pedagogically in this jupyter-book, particularly chapters 1-3.</p> <p>Let's get to it then. First, we'll import all the modules we need and set up the scattering system.</p>"},{"location":"tutorials/ROSE_tutorial_1_building_an_emulator/#setting-up-the-scattering-system","title":"Setting up the scattering system\u00b6","text":"<p>We start by making some preliminary definitions for constants.</p>"},{"location":"tutorials/ROSE_tutorial_1_building_an_emulator/#define-the-interaction-an-optical-model-potential","title":"Define the interaction: an optical model potential\u00b6","text":"<p>Let's define the functional forms for the interaction potentials we will use. We will use standard forms of the optical potential, with default parameters for $^{40}$Ca, as defined by Koning and Delaroche. Although these are already implemented in <code>rose.koning_delaroche</code>, we will implemement them from scratch below for purposes of demonstration on how to provide your own interaction in <code>rose</code>.</p> <p>The potential we use includes the following terms, each with a set of parameters:</p> <ol> <li>complex volume term with a Woods-Saxon shape; $V_v$, $W_v$, $R_v$, $a_v$</li> <li>imaginary surface-peaked term with a Woods-Saxon derivative shape; $W_d$, $R_d$, $a_d$</li> <li>complex spin-orbit (SO) coupling term with a Woods-Saxon derivative shape; $V_{so}$, $W_{so}$, $R_{so}$, $a_{so}$.</li> </ol> <p>\\begin{equation}     \\begin{aligned}       &amp;V(r;\\alpha,\\ell,j) =-(V_v +iW_v)f_\\text{WS}(r,R_v,a_v)  \\\\       &amp;-i4a_dW_d \\frac{d}{dr}f_\\text{WS}(r,R_d,a_d) \\\\       &amp;+2\\ell\\cdot s (V_{so} + iW_{so})  \\Big(\\frac{\\hbar}{m_\\pi c}\\Big)^2 \\frac{1}{r} \\frac{d}{dr}f_\\text{WS}(R_{so},a_{so}),     \\end{aligned} \\end{equation}</p> <p>The Woods-Saxon functional form (and it's derivative) is our model for the geometric shape of the effective potential the neutron feels as a function of it's distance from the $^{40}$ Ca nucleus. It looks like this:</p> <p>\\begin{equation} f(r;R,a) = \\frac{1}{1 - \\exp{\\frac{r-R}{a}}}. \\end{equation}</p> <p>All depth parameters ($V_i$, $W_i$) are given in MeV, and geometric parameters $r_i$ and $a_i$ are given in fm. We define our vector of parameters as</p> <p>\\begin{equation} \\boldsymbol{\\alpha} = \\begin{bmatrix} V_v &amp;  W_v &amp; R_v &amp; a_v &amp; W_d &amp; R_d &amp; a_d &amp; V_{so} &amp; W_{so} &amp; R_{so} &amp; a_{so} \\end{bmatrix} \\end{equation}</p> <p>One final thing - we will need to decorate our implementation of this interaction with <code>@njit</code>, so <code>rose</code> can compile it for performance.</p> <p>Let's set this up:</p>"},{"location":"tutorials/ROSE_tutorial_1_building_an_emulator/#set-up-the-training-and-testing-regions-for-the-emulator","title":"Set up the training and testing regions for the emulator\u00b6","text":"<p>It is now our goal to define an emulator that, given an arbitrary point in a closed subset of this 11D space, reproduces the scattering solutions of the Schr\u00f6dinger equation for the center-of-mass frame of a 14.1 MeV neutron and a $^{40}$ Ca nucleus. To do this, we will use a high-fidelity (HF) solver to construct a basis of solutions as we perturb $\\boldsymbol{\\alpha}$ around our region of interest, and then construct a suitable reduced basis emulator from it.</p> <p>Notice that the functional form of the Woods-Saxon (and its derivative) is not a simple linear function of the parameters $R$ and $a$. To be more precise, we can't factorize this function into the product of functions of just the parameters $R$ and $a$, and another function of just the domain of the problem $r$. A mathematician would say that this operator is not \"affine\" in the geometric parameters. To handle emulating the potential operator, we will need to construct an approximation that is factorizable using something called the Empirical Interplation Method (EIM). Chapters 2 and 3 of this book contain a more detail view (within a nuclear physics context) of the reduced basis method and the empirical interpolation method we use in ROSE.</p> <p>In summary, the EIM consists of approximating the potential with $m$ reduced basis in the same way as we did for our solutions:</p> <p>\\begin{equation} V(r; \\alpha)  \\approx V_\\text{EIM} (r; \\alpha)  = \\sum_k^m \\beta_k(\\alpha) V_k(r). \\end{equation}</p> <p>Fortunately, ROSE will handle all of these details for us, so we don't have to get our hands too dirty! Let's take a look at how to use ROSE to make ourselves a nice emulator.</p> <p>We will create training boundaries 20% above and below our mean values for the parameters, and therefore define the bounds of a hyper-box in our 11D parameter space that contains this region of interst. We will train our emulator with random samples of $\\alpha$ from this box, and we would like to be accurate throughout the entire box.</p>"},{"location":"tutorials/ROSE_tutorial_1_building_an_emulator/#construct-the-interaction-space-high-fidelity-solver-and-emulator","title":"Construct the interaction space, high-fidelity solver, and emulator\u00b6","text":"<p>Great, we have all the points we need to sample. Now let's define an <code>InteractionEIMSpace</code> in <code>rose</code>, which encodes the original, and Empirically-Interpolated, potentials we've defined; one for each partial wave. Then we will use this to construct our emulators and our High-Fidelity (HF) solver, and take a look at how snapshots of the HF solutions vary over our training space.  We will use the default EIM setup. ROSE will automatically use the exact potential for the HF solver, and the EIM decomposed potential for emulation.</p> <p>By the way, we like to call HF solutions of our system \"snapshots\". In this case, we use snapshots to refer to the test observables (differential cross sections), but we will also use it to refer to the training wavefunctions we generate with the HF solver, which ROSE uses to construct the reduced basis.</p> <p>We will start by using a reduced basis of 4 elements, and the same number of EIM terms as there are parameters in $\\boldsymbol{\\alpha}$; in this case, 11. We will pass in the bounds of our parameter space, and the <code>InteractionEIMSpace</code> object will automatically find 1000 (by default) well-distributed points in our parameter space to train the EIM factorization. These are fairly sensible defaults, but can be easily changed.</p>"},{"location":"tutorials/ROSE_tutorial_1_building_an_emulator/#spot-checks","title":"Spot checks\u00b6","text":"<p>Let's plot a few cross sections, wave functions, and phase shifts to see how the emulator compared to the high-fidelity.</p>"},{"location":"tutorials/ROSE_tutorial_2_optical_potential_surmise_UQ/","title":"UQ for an Optical Potential!","text":"<p>We will use the emulator with 15 EIM terms and 15 basis elements from the previous tutorial, as it gives us sub per-mille error in differential cross sections while providing more than 100 samples per second:</p> <p></p> <p>We see that the median of our emulator error was around 10^-4 and we will use that as a rough estimate of the expected error. Be mindful that, when selecting the emulator configuration (15,15) we used 50 test samples from a box of $20\\%$ in the parameter space, and we expect that if our random walkers get to far from this training region the emulator quality will decrease.</p> <p>First we quickly create our emulator, copying the problem setup from the previous tutorial:</p> In\u00a0[4]: Copied! <pre>#(if you don't have it already)\n#!pip install nuclear-rose \n\nimport rose\nfrom numba import njit # we need to this to Just-In-Time (JIT) compile our interaction\n\n# other nice things\nimport numpy as np\nimport time\nimport os\nfrom scipy.stats import qmc\n\n# import stuff for nice plotting\nimport matplotlib.pyplot as plt\nfrom matplotlib.lines import Line2D\nimport scipy.stats as sps\nfrom tqdm import tqdm\nimport random\nimport datetime\nimport seaborn as sns\n# !pip install corner\nimport corner\n\n\nplt.rcParams.update({'font.size': 12})\nprint(rose.__version__)\n</pre> #(if you don't have it already) #!pip install nuclear-rose   import rose from numba import njit # we need to this to Just-In-Time (JIT) compile our interaction  # other nice things import numpy as np import time import os from scipy.stats import qmc  # import stuff for nice plotting import matplotlib.pyplot as plt from matplotlib.lines import Line2D import scipy.stats as sps from tqdm import tqdm import random import datetime import seaborn as sns # !pip install corner import corner   plt.rcParams.update({'font.size': 12}) print(rose.__version__) <pre>1.1.4.dev12+gd0ad2eb.d20250117\n</pre> In\u00a0[5]: Copied! <pre>from matplotlib.ticker import StrMethodFormatter\nfrom matplotlib.lines import Line2D\nfrom matplotlib.ticker import MaxNLocator\nfrom matplotlib import pyplot as plt\nfrom matplotlib import rcParams\nfrom rose.training import multiple_formatter\n\ncolors = [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\",\n]\n\n# plt.rc(\"font\", **{\"family\": \"serif\", \"serif\": [\"Computer Modern\"]})\n# rcParams[\n#     \"text.latex.preamble\"\n# ] = r\"\\usepackage{amssymb} \\usepackage{amsmath} \\usepackage{braket}\"\nplt.rc(\"text\", usetex=False)\n\nrcParams[\"legend.fontsize\"] = 12\nrcParams[\"font.size\"] = 12\nrcParams[\"font.weight\"] = \"normal\"\nrcParams[\"xtick.labelsize\"] = 12.0\nrcParams[\"ytick.labelsize\"] = 12.0\nrcParams[\"lines.linewidth\"] = 2.0\nrcParams[\"xtick.major.pad\"] = \"10\"\nrcParams[\"ytick.major.pad\"] = \"10\"\nrcParams[\"image.cmap\"] = \"BuPu\"\n</pre> from matplotlib.ticker import StrMethodFormatter from matplotlib.lines import Line2D from matplotlib.ticker import MaxNLocator from matplotlib import pyplot as plt from matplotlib import rcParams from rose.training import multiple_formatter  colors = [     \"#1f77b4\",     \"#ff7f0e\",     \"#2ca02c\",     \"#d62728\",     \"#9467bd\",     \"#8c564b\",     \"#e377c2\",     \"#7f7f7f\",     \"#bcbd22\",     \"#17becf\", ]  # plt.rc(\"font\", **{\"family\": \"serif\", \"serif\": [\"Computer Modern\"]}) # rcParams[ #     \"text.latex.preamble\" # ] = r\"\\usepackage{amssymb} \\usepackage{amsmath} \\usepackage{braket}\" plt.rc(\"text\", usetex=False)  rcParams[\"legend.fontsize\"] = 12 rcParams[\"font.size\"] = 12 rcParams[\"font.weight\"] = \"normal\" rcParams[\"xtick.labelsize\"] = 12.0 rcParams[\"ytick.labelsize\"] = 12.0 rcParams[\"lines.linewidth\"] = 2.0 rcParams[\"xtick.major.pad\"] = \"10\" rcParams[\"ytick.major.pad\"] = \"10\" rcParams[\"image.cmap\"] = \"BuPu\" In\u00a0[6]: Copied! <pre># targets and projectiles defined by (A,Z)\nCa40 = (40,20)\np = (1,1)\n\n# set up kinematics\nE_lab = 14.1 # MeV - like from a DT generator\nmu, E_com, k, eta = rose.kinematics(target=Ca40, projectile=p, E_lab=E_lab)\n\n# domain of the differential cross section; the observable we want to emulate\n# we will evaluate the accuracy of our emulator by comparing dsigma/dtheta on this domain \nangles = np.linspace(1, 179, 200) * np.pi / 180\n</pre> # targets and projectiles defined by (A,Z) Ca40 = (40,20) p = (1,1)  # set up kinematics E_lab = 14.1 # MeV - like from a DT generator mu, E_com, k, eta = rose.kinematics(target=Ca40, projectile=p, E_lab=E_lab)  # domain of the differential cross section; the observable we want to emulate # we will evaluate the accuracy of our emulator by comparing dsigma/dtheta on this domain  angles = np.linspace(1, 179, 200) * np.pi / 180 In\u00a0[7]: Copied! <pre>from rose.utility import woods_saxon, woods_saxon_prime\n\n# total potential with a real and central term (with the same geometry)\n# and imaginary surface-peaked term, but no SO coupling\n@njit\ndef optical_potential(r, theta):\n    Vv, Wv, Wd, Vso, Wso, Rv, Rd, Rso, av, ad, aso = theta\n    return (1j * Wv - Vv) * woods_saxon(r, Rv, av) - (4j * ad * Wd) * woods_saxon_prime(\n        r, Rd, ad\n    )\n\n# spin orbit interaction constant\nmso = 1.0 / rose.constants.MASS_PION\n\n# spin-orbit (SO) coulpling term - a function of l dot s, l being the orbital angular momentum\n# and s being the spin of the neutron\n@njit\ndef spin_orbit_potential(r, theta, ldots):\n    Vv, Wv, Wd, Vso, Wso, Rv, Rd, Rso, av, ad, aso = theta\n    return (Vso + 1j * Wso) * mso**2 * ldots * woods_saxon_prime(r, Rso, aso) / r\n\n\n# the total number of parameters\nnparams = 11\n</pre> from rose.utility import woods_saxon, woods_saxon_prime  # total potential with a real and central term (with the same geometry) # and imaginary surface-peaked term, but no SO coupling @njit def optical_potential(r, theta):     Vv, Wv, Wd, Vso, Wso, Rv, Rd, Rso, av, ad, aso = theta     return (1j * Wv - Vv) * woods_saxon(r, Rv, av) - (4j * ad * Wd) * woods_saxon_prime(         r, Rd, ad     )  # spin orbit interaction constant mso = 1.0 / rose.constants.MASS_PION  # spin-orbit (SO) coulpling term - a function of l dot s, l being the orbital angular momentum # and s being the spin of the neutron @njit def spin_orbit_potential(r, theta, ldots):     Vv, Wv, Wd, Vso, Wso, Rv, Rd, Rso, av, ad, aso = theta     return (Vso + 1j * Wso) * mso**2 * ldots * woods_saxon_prime(r, Rso, aso) / r   # the total number of parameters nparams = 11 In\u00a0[8]: Copied! <pre># This is the value of the parameters coming from the Koning-Delaroche parametrization.\n# Taken from https://www-nds.iaea.org/RIPL-3/\nVvKD = 46.7238\nWvKD = 1.72334\nWdKD = -7.2357\nVsoKD = 6.1\nWsoKD = -3.1\n\nRvKD = 4.0538\nRdKD = 4.4055\nRsoKD = 1.01 * 40 ** (1.0 / 3.0)\n\navKD = 0.6718\nadKD = 0.5379\nasoKD = 0.60\n\nalpha_central = np.array(\n    [VvKD, WvKD, WdKD, VsoKD, WsoKD, RvKD, RdKD, RsoKD, avKD, adKD, asoKD]\n)\n</pre> # This is the value of the parameters coming from the Koning-Delaroche parametrization. # Taken from https://www-nds.iaea.org/RIPL-3/ VvKD = 46.7238 WvKD = 1.72334 WdKD = -7.2357 VsoKD = 6.1 WsoKD = -3.1  RvKD = 4.0538 RdKD = 4.4055 RsoKD = 1.01 * 40 ** (1.0 / 3.0)  avKD = 0.6718 adKD = 0.5379 asoKD = 0.60  alpha_central = np.array(     [VvKD, WvKD, WdKD, VsoKD, WsoKD, RvKD, RdKD, RsoKD, avKD, adKD, asoKD] ) In\u00a0[9]: Copied! <pre>scale_training = 0.2\nbounds = np.array(\n        [\n            alpha_central - np.fabs(alpha_central * scale_training),\n            alpha_central + np.fabs(alpha_central * scale_training),\n        ]\n    ).T\n</pre> scale_training = 0.2 bounds = np.array(         [             alpha_central - np.fabs(alpha_central * scale_training),             alpha_central + np.fabs(alpha_central * scale_training),         ]     ).T <p>Great, we have our potential and parameters set up. Before we create our emulator, let's take a look at the experimental data we want to fit.</p> In\u00a0[10]: Copied! <pre># Angles where d xs / s theta was measured, in degrees, \n# 0 being transmission, 180 being reflection back to the beamline\n\ncos_theta = np.array(\n    [\n        0.93420,\n        0.85630,\n        0.76150,\n        # 0.75470,  This particular measurement seems to be miss-transcribed in the data set. I replaced by the one below (41 deg to 51 deg)\n        0.64279,\n        0.46640,\n        0.28740,\n        0.17360,\n        -0.0419,\n        -0.2181,\n        -0.3616,\n        -0.5240,\n        -0.6665,\n        -0.8141,\n        -0.9342,\n    ]\n)\n\nanglesX = np.array(\n    [np.arccos(cos_theta[i]) / np.pi * 180 for i in range(len(cos_theta))]\n)\n\n\n# corresponding experimental cross sections\ndxs = np.array(\n    [\n        5.34e02,\n        1.06e02,\n        3.27e01,\n        5.10e01,\n        4.69e01,\n        1.20e01,\n        1.39e01,\n        2.09e01,\n        2.77e01,\n        1.28e01,\n        8.2e00,\n        4.7e00,\n        7.0e00,\n        7.4e00,\n    ]\n)\n\n# experimental error\ndxs_err = np.array(\n    [\n        2.3e01,\n        7.0e0,\n        4.0e0,\n        3.5e0,\n        2.9e0,\n        1.7e0,\n        1.7e0,\n        2.0e0,\n        1.8e0,\n        1.4e0,\n        1.7e0,\n        9.0e-01,\n        1.3e0,\n        1.9e0,\n    ]\n)\n\nangular_resolution = 11  # degrees\n\nplt.yscale(\"log\")\n# plt.errorbar(anglesX, dxs, dxs_err, xerr=angular_resolution, linestyle=\"none\", marker=\".\")\nplt.errorbar(anglesX, dxs, dxs_err, linestyle=\"none\", marker=\".\")\nplt.xlim([0, 180])\nplt.xlabel(r\"$\\theta$ [$^\\circ$]\")\nplt.ylabel(r\"$\\frac{d \\sigma}{d \\theta}$ [mb/sr]\")\nplt.title(\"McDonald and Robson Neutrons on 40Ca at 14 MeV\")\n\nplt.rc(\"xtick\", labelsize=15)  # fontsize of the tick labels\nplt.rc(\"ytick\", labelsize=15)\n\nplt.show()\n</pre> # Angles where d xs / s theta was measured, in degrees,  # 0 being transmission, 180 being reflection back to the beamline  cos_theta = np.array(     [         0.93420,         0.85630,         0.76150,         # 0.75470,  This particular measurement seems to be miss-transcribed in the data set. I replaced by the one below (41 deg to 51 deg)         0.64279,         0.46640,         0.28740,         0.17360,         -0.0419,         -0.2181,         -0.3616,         -0.5240,         -0.6665,         -0.8141,         -0.9342,     ] )  anglesX = np.array(     [np.arccos(cos_theta[i]) / np.pi * 180 for i in range(len(cos_theta))] )   # corresponding experimental cross sections dxs = np.array(     [         5.34e02,         1.06e02,         3.27e01,         5.10e01,         4.69e01,         1.20e01,         1.39e01,         2.09e01,         2.77e01,         1.28e01,         8.2e00,         4.7e00,         7.0e00,         7.4e00,     ] )  # experimental error dxs_err = np.array(     [         2.3e01,         7.0e0,         4.0e0,         3.5e0,         2.9e0,         1.7e0,         1.7e0,         2.0e0,         1.8e0,         1.4e0,         1.7e0,         9.0e-01,         1.3e0,         1.9e0,     ] )  angular_resolution = 11  # degrees  plt.yscale(\"log\") # plt.errorbar(anglesX, dxs, dxs_err, xerr=angular_resolution, linestyle=\"none\", marker=\".\") plt.errorbar(anglesX, dxs, dxs_err, linestyle=\"none\", marker=\".\") plt.xlim([0, 180]) plt.xlabel(r\"$\\theta$ [$^\\circ$]\") plt.ylabel(r\"$\\frac{d \\sigma}{d \\theta}$ [mb/sr]\") plt.title(\"McDonald and Robson Neutrons on 40Ca at 14 MeV\")  plt.rc(\"xtick\", labelsize=15)  # fontsize of the tick labels plt.rc(\"ytick\", labelsize=15)  plt.show() <p>We will build our emulator to predict the CS over the fine grid of angles so we can have relatively continous plots in the end, but we need to be sure that when calibrating with the data, the ROSE emulator is predicting only on the 14 actual points of data.</p> In\u00a0[11]: Copied! <pre>from rose.training import sample_params_LHC \nn_train = 80\nseed_train = 142857\ntraining_samples = sample_params_LHC(\n    n_train, alpha_central, scale=scale_training, seed=seed_train\n)\n</pre> from rose.training import sample_params_LHC  n_train = 80 seed_train = 142857 training_samples = sample_params_LHC(     n_train, alpha_central, scale=scale_training, seed=seed_train ) In\u00a0[12]: Copied! <pre>interactions = rose.InteractionEIMSpace(\n    coordinate_space_potential=optical_potential,\n    n_theta = nparams,\n    mu=mu,\n    energy=E_com,\n    is_complex=True,\n    spin_orbit_term=spin_orbit_potential,\n    training_info=bounds,\n    n_basis=15,\n)\n</pre> interactions = rose.InteractionEIMSpace(     coordinate_space_potential=optical_potential,     n_theta = nparams,     mu=mu,     energy=E_com,     is_complex=True,     spin_orbit_term=spin_orbit_potential,     training_info=bounds,     n_basis=15, ) In\u00a0[13]: Copied! <pre># let's build our first reduced basis emulator\nbase_solver = rose.SchroedingerEquation.make_base_solver(\n    s_0=6 * np.pi, rk_tols=[1e-10, 1e-10], domain=np.array([1e-8, 8 * np.pi])\n)\nrose_emulator = rose.ScatteringAmplitudeEmulator.from_train(\n    interactions,\n    training_samples,\n    n_basis=15, \n    angles=angles,\n    base_solver=base_solver,\n    scale=True,\n    use_svd=True,\n)\n</pre> # let's build our first reduced basis emulator base_solver = rose.SchroedingerEquation.make_base_solver(     s_0=6 * np.pi, rk_tols=[1e-10, 1e-10], domain=np.array([1e-8, 8 * np.pi]) ) rose_emulator = rose.ScatteringAmplitudeEmulator.from_train(     interactions,     training_samples,     n_basis=15,      angles=angles,     base_solver=base_solver,     scale=True,     use_svd=True, ) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 16/16 [02:08&lt;00:00,  8.04s/it]\n</pre> In\u00a0[14]: Copied! <pre># In this default we are assuming uncorrelated Gaussian priors. \n# Advanced users can provide covariance matrices for correlations\n\n# Specifying the priors, we believe the answer that explains the data shouldn't be too \n# far away from the KD parameters\nalpha_central_prior = alpha_central\n\n# We are using Gaussian priors with a standard deviation of 15% of their respective centers\nsigma_prior = [abs(param_val * 0.15) for param_val in alpha_central_prior]\n\n# We use a smaller scale for the starting values of the MCMC chains so that we minimize \n# the chances of one starting in a negative value of the diffuseness or the radii\n\n# This scale is very important: since the optical potential posterior parameter surface \n# is highly multimodal we would like to limit ourself for this tutorial to study a vicinity\n# of the main mode closer to our prior. We will start our walkers very close to the prior \n# center.\nMCMC_scale = [abs(param_val * 0.01) for param_val in alpha_central_prior]\n\n# This error scale comes from the CAT plot we showed at the begining. \nemulator_error = 5 * 10 ** (-4)\n</pre> # In this default we are assuming uncorrelated Gaussian priors.  # Advanced users can provide covariance matrices for correlations  # Specifying the priors, we believe the answer that explains the data shouldn't be too  # far away from the KD parameters alpha_central_prior = alpha_central  # We are using Gaussian priors with a standard deviation of 15% of their respective centers sigma_prior = [abs(param_val * 0.15) for param_val in alpha_central_prior]  # We use a smaller scale for the starting values of the MCMC chains so that we minimize  # the chances of one starting in a negative value of the diffuseness or the radii  # This scale is very important: since the optical potential posterior parameter surface  # is highly multimodal we would like to limit ourself for this tutorial to study a vicinity # of the main mode closer to our prior. We will start our walkers very close to the prior  # center. MCMC_scale = [abs(param_val * 0.01) for param_val in alpha_central_prior]  # This error scale comes from the CAT plot we showed at the begining.  emulator_error = 5 * 10 ** (-4) <p>We will use <code>surmise</code>, another BAND-developed package for connecting all the tools and softwares (such as our <code>rose</code> emulator) for performing Bayesian analysis.</p> <p>Check out surmise's documentation webpage for more information: https://surmise.readthedocs.io/en/latest/</p> In\u00a0[15]: Copied! <pre># uncomment and run this if you don't have surmise installed\n# !pip install surmise\n</pre> # uncomment and run this if you don't have surmise installed # !pip install surmise In\u00a0[16]: Copied! <pre># check for surmise-0.2.1.dev14\nimport surmise\nimport importlib\n\nimportlib.reload(surmise)\nprint(surmise.__version__)\n</pre> # check for surmise-0.2.1.dev14 import surmise import importlib  importlib.reload(surmise) print(surmise.__version__) <pre>0.3.0\n</pre> <p>Our sample rate for the emulator is around 10 miliseconds, which means around 6k samples per minute. We are choosing a relatively small amount of samples and chains to have the calibration done in a couple of minutes. You can of course run it for longer and obtain millions of samples to build very detailed and rich corner plots.</p> In\u00a0[17]: Copied! <pre>from surmise.emulation import emulator\nfrom surmise.calibration import calibrator\n\nX = np.copy(anglesX) / 180 * np.pi\ny = np.copy(dxs)  # data we want to fit\nyerr = np.copy(dxs_err)  # err in data\n\nstep_sizes0 = 0.02 * np.abs(alpha_central)\n\nnsamples = 5000\ntotal_chains = 10\nncores = 8\nburn_samples0 = 500\n</pre> from surmise.emulation import emulator from surmise.calibration import calibrator  X = np.copy(anglesX) / 180 * np.pi y = np.copy(dxs)  # data we want to fit yerr = np.copy(dxs_err)  # err in data  step_sizes0 = 0.02 * np.abs(alpha_central)  nsamples = 5000 total_chains = 10 ncores = 8 burn_samples0 = 500 In\u00a0[18]: Copied! <pre>class prior_scattering:\n    \"\"\"This defines the class instance of priors provided to the method.\"\"\"\n\n    def lpdf(theta):\n        total_prior_pdf = sps.norm.logpdf(\n            theta[:, 0], alpha_central_prior[0], sigma_prior[0]\n        )\n\n        for i in range(1, len(alpha_central_prior)):\n            total_prior_pdf = total_prior_pdf + sps.norm.logpdf(\n                theta[:, i], alpha_central_prior[i], sigma_prior[i]\n            )\n\n        return (total_prior_pdf).reshape((len(theta), 1))\n\n    def rnd(n):\n        total_rand_samples = np.empty((len(alpha_central_prior),n))\n        for i in range(len(alpha_central_prior)):\n            smp = sps.norm.rvs(alpha_central_prior[i], MCMC_scale[i], size=n)\n            total_rand_samples[i,...] = smp\n        return total_rand_samples.T\n</pre> class prior_scattering:     \"\"\"This defines the class instance of priors provided to the method.\"\"\"      def lpdf(theta):         total_prior_pdf = sps.norm.logpdf(             theta[:, 0], alpha_central_prior[0], sigma_prior[0]         )          for i in range(1, len(alpha_central_prior)):             total_prior_pdf = total_prior_pdf + sps.norm.logpdf(                 theta[:, i], alpha_central_prior[i], sigma_prior[i]             )          return (total_prior_pdf).reshape((len(theta), 1))      def rnd(n):         total_rand_samples = np.empty((len(alpha_central_prior),n))         for i in range(len(alpha_central_prior)):             smp = sps.norm.rvs(alpha_central_prior[i], MCMC_scale[i], size=n)             total_rand_samples[i,...] = smp         return total_rand_samples.T In\u00a0[86]: Copied! <pre>def calibration_runner(rbm, x, y, obsvar, test_params, numsamp, i, caldir):\n    cal = calibrator(\n        emu=rbm,\n        y=y,\n        x=x,\n        thetaprior=prior_scattering,\n        method=\"directbayes\",\n        yvar=obsvar,\n        args={\n            \"theta0\": test_params.reshape(1, nparams),\n            \"sampler\": \"metropolis_hastings\",\n            \"numsamp\": numsamp,\n            \"stepType\": \"normal\",\n            \"stepParam\": step_sizes0,\n            \"burnSamples\": burn_samples0,\n            \"verbose\": True,\n        },\n    )\n    \n    calfile = os.path.join(caldir, \"caltheta_{}.out\".format(i))\n    np.savetxt(calfile, cal.info[\"thetarnd\"])\n    \n    pred = cal.predict(x)\n    coverage = pred.info['coverage']\n    print('Coverage (nominal and empirical probability):', coverage)\n    \n    coveragefile = os.path.join(caldir, \"coverage_{}.txt\".format(i))\n    np.savetxt(coveragefile, coverage)\n    \n    return cal.info[\"thetarnd\"]\n</pre> def calibration_runner(rbm, x, y, obsvar, test_params, numsamp, i, caldir):     cal = calibrator(         emu=rbm,         y=y,         x=x,         thetaprior=prior_scattering,         method=\"directbayes\",         yvar=obsvar,         args={             \"theta0\": test_params.reshape(1, nparams),             \"sampler\": \"metropolis_hastings\",             \"numsamp\": numsamp,             \"stepType\": \"normal\",             \"stepParam\": step_sizes0,             \"burnSamples\": burn_samples0,             \"verbose\": True,         },     )          calfile = os.path.join(caldir, \"caltheta_{}.out\".format(i))     np.savetxt(calfile, cal.info[\"thetarnd\"])          pred = cal.predict(x)     coverage = pred.info['coverage']     print('Coverage (nominal and empirical probability):', coverage)          coveragefile = os.path.join(caldir, \"coverage_{}.txt\".format(i))     np.savetxt(coveragefile, coverage)          return cal.info[\"thetarnd\"] In\u00a0[87]: Copied! <pre>random.seed(142857)\n\nobsvar = 1.0 * np.square(yerr)\n\ncaldir = os.path.join(\n    os.getcwd(), \"Cal-\" + datetime.datetime.now().strftime(\"%Y-%m-%d_%H-%M\")\n)\nos.makedirs(caldir, exist_ok=True)\n\nrand_params = prior_scattering.rnd(total_chains)\n</pre> random.seed(142857)  obsvar = 1.0 * np.square(yerr)  caldir = os.path.join(     os.getcwd(), \"Cal-\" + datetime.datetime.now().strftime(\"%Y-%m-%d_%H-%M\") ) os.makedirs(caldir, exist_ok=True)  rand_params = prior_scattering.rnd(total_chains) In\u00a0[88]: Copied! <pre>rbm = emulator(\n    method=\"nuclear-ROSE\",\n    args={\n        \"rose_emu\": rose_emulator,\n        \"emu_variance_constant\": emulator_error,\n        \"angle_atol\": 1e-1,\n    },\n)\n</pre> rbm = emulator(     method=\"nuclear-ROSE\",     args={         \"rose_emu\": rose_emulator,         \"emu_variance_constant\": emulator_error,         \"angle_atol\": 1e-1,     }, ) In\u00a0[89]: Copied! <pre>%%time\nsep_chains = []\nchain0 = calibration_runner(rbm, X, y, obsvar, rand_params[0], nsamples, 0, caldir)\nsep_chains.append(chain0)\nall_chains = chain0\n\nfor ij in range(total_chains - 1):\n    current_cal = calibration_runner(\n        rbm, X, y, obsvar, rand_params[ij], nsamples, ij + 1, caldir\n    )\n\n    all_chains = np.vstack(\n        (\n            all_chains,\n            current_cal,\n        )\n    )\n\n    sep_chains.append(current_cal)\n\nsep_chains = np.array(sep_chains)\n</pre> %%time sep_chains = [] chain0 = calibration_runner(rbm, X, y, obsvar, rand_params[0], nsamples, 0, caldir) sep_chains.append(chain0) all_chains = chain0  for ij in range(total_chains - 1):     current_cal = calibration_runner(         rbm, X, y, obsvar, rand_params[ij], nsamples, ij + 1, caldir     )      all_chains = np.vstack(         (             all_chains,             current_cal,         )     )      sep_chains.append(current_cal)  sep_chains = np.array(sep_chains) <pre>Final Acceptance Rate:  0.087\n(array([0.68, 0.9 , 0.95, 0.99]), array([0.28571429, 0.42857143, 0.42857143, 0.57142857]))\nFinal Acceptance Rate:  0.087\n(array([0.68, 0.9 , 0.95, 0.99]), array([0.28571429, 0.35714286, 0.5       , 0.71428571]))\nFinal Acceptance Rate:  0.0938\n(array([0.68, 0.9 , 0.95, 0.99]), array([0.28571429, 0.42857143, 0.57142857, 0.78571429]))\nFinal Acceptance Rate:  0.1022\n(array([0.68, 0.9 , 0.95, 0.99]), array([0.28571429, 0.42857143, 0.64285714, 0.71428571]))\nFinal Acceptance Rate:  0.0942\n(array([0.68, 0.9 , 0.95, 0.99]), array([0.21428571, 0.42857143, 0.5       , 0.64285714]))\nFinal Acceptance Rate:  0.098\n(array([0.68, 0.9 , 0.95, 0.99]), array([0.28571429, 0.42857143, 0.57142857, 0.71428571]))\nFinal Acceptance Rate:  0.0874\n(array([0.68, 0.9 , 0.95, 0.99]), array([0.21428571, 0.42857143, 0.42857143, 0.64285714]))\nFinal Acceptance Rate:  0.0916\n(array([0.68, 0.9 , 0.95, 0.99]), array([0.28571429, 0.42857143, 0.5       , 0.64285714]))\nFinal Acceptance Rate:  0.1032\n(array([0.68, 0.9 , 0.95, 0.99]), array([0.28571429, 0.35714286, 0.35714286, 0.78571429]))\nFinal Acceptance Rate:  0.0998\n(array([0.68, 0.9 , 0.95, 0.99]), array([0.28571429, 0.42857143, 0.5       , 0.64285714]))\nCPU times: total: 1min 23s\nWall time: 1min 25s\n</pre> In\u00a0[90]: Copied! <pre># Getting the same number of samples from the prior so we can compare the two\nsamples_prior = np.empty((len(alpha_central_prior),10000))\nfor i in range(len(alpha_central_prior)):\n    samples_prior[i] = sps.norm.rvs(alpha_central_prior[i], sigma_prior[i], size=10000)\n\nsamples_prior = samples_prior.T\n</pre> # Getting the same number of samples from the prior so we can compare the two samples_prior = np.empty((len(alpha_central_prior),10000)) for i in range(len(alpha_central_prior)):     samples_prior[i] = sps.norm.rvs(alpha_central_prior[i], sigma_prior[i], size=10000)  samples_prior = samples_prior.T In\u00a0[91]: Copied! <pre># The plotting routinge to make the gorgeous corner plots! For some reason we have to run \n# it twice to make the label size for the ticks to be correct\n\nplt.rc(\"xtick\", labelsize=30)\nplt.rc(\"ytick\", labelsize=30)\n\nbins_target = 20\nws = [\n    abs(max(all_chains[:, i]) - min(all_chains[:, i])) / bins_target\n    for i in range(len(all_chains.T))\n]\n\nfigure = corner.corner(\n    samples_prior,\n    labels=[\n        \"$V_v$\",\n        \"$W_v$\",\n        \"$W_d$\",\n        \"$V_{so}$\",\n        \"$W_{so}$\",\n        \"$R_v$\",\n        \"$R_d$\",\n        \"$R_{so}$\",\n        \"$a_v$\",\n        \"$a_d$\",\n        \"$a_{so}$\",\n    ],\n    labelpad=0.2,\n    weights=np.full(len(samples_prior), (len(all_chains)) / (len(samples_prior))),\n    bins=[\n        int(abs(max(samples_prior[:, i]) - min(samples_prior[:, i])) / ws[i])\n        for i in range(len(samples_prior.T))\n    ],\n    color=\"b\",\n    # bins=20,\n    label_kwargs={\"fontsize\": 40},\n    hist_kwargs={\"linewidth\": 3},\n    quantiles=None,\n    truths=alpha_central,\n    truth_color=\"r\",\n    smooth=(1.7),\n    smooth1d=1.0,\n    max_n_ticks=2\n)\n\n\ncorner.corner(\n    all_chains,\n    fig=figure,\n    labels=[\n        \"$V_v$\",\n        \"$W_v$\",\n        \"$W_d$\",\n        \"$V_{so}$\",\n        \"$W_{so}$\",\n        \"$R_v$\",\n        \"$R_d$\",\n        \"$R_{so}$\",\n        \"$a_v$\",\n        \"$a_d$\",\n        \"$a_{so}$\",\n    ],\n    labelpad=0.2,\n    # bins=20,\n    bins=[\n        int(abs(max(all_chains[:, i]) - min(all_chains[:, i])) / ws[i])\n        for i in range(len(all_chains.T))\n    ],\n    label_kwargs={\"fontsize\": 40},\n    hist_kwargs={\"linewidth\": 3},\n    quantiles=None,\n    truths=alpha_central,\n    truth_color=\"r\",\n    smooth=(1.7),\n    smooth1d=1.0,\n    max_n_ticks=2\n)\n\n\ndim = len(all_chains[0])\nranges = [\n    [min(all_chains[:, i]), max(all_chains[:, i])] for i in range(len(all_chains.T))\n]\n\naxes = np.array(figure.axes).reshape((dim, dim))\n# print()\nfor i in range(dim):\n    ax = axes[i, i]\n    ax.set_xlim(ranges[i][0], ranges[i][1])\n\n    for j in range(i):\n        ax = axes[i, j]\n        ax.set_ylim(ranges[i][0], ranges[i][1])\n        ax.set_xlim(ranges[j][0], ranges[j][1])\n\n\nwidth = 24\nheight = 18\nfigure.set_size_inches(width, height)\n</pre> # The plotting routinge to make the gorgeous corner plots! For some reason we have to run  # it twice to make the label size for the ticks to be correct  plt.rc(\"xtick\", labelsize=30) plt.rc(\"ytick\", labelsize=30)  bins_target = 20 ws = [     abs(max(all_chains[:, i]) - min(all_chains[:, i])) / bins_target     for i in range(len(all_chains.T)) ]  figure = corner.corner(     samples_prior,     labels=[         \"$V_v$\",         \"$W_v$\",         \"$W_d$\",         \"$V_{so}$\",         \"$W_{so}$\",         \"$R_v$\",         \"$R_d$\",         \"$R_{so}$\",         \"$a_v$\",         \"$a_d$\",         \"$a_{so}$\",     ],     labelpad=0.2,     weights=np.full(len(samples_prior), (len(all_chains)) / (len(samples_prior))),     bins=[         int(abs(max(samples_prior[:, i]) - min(samples_prior[:, i])) / ws[i])         for i in range(len(samples_prior.T))     ],     color=\"b\",     # bins=20,     label_kwargs={\"fontsize\": 40},     hist_kwargs={\"linewidth\": 3},     quantiles=None,     truths=alpha_central,     truth_color=\"r\",     smooth=(1.7),     smooth1d=1.0,     max_n_ticks=2 )   corner.corner(     all_chains,     fig=figure,     labels=[         \"$V_v$\",         \"$W_v$\",         \"$W_d$\",         \"$V_{so}$\",         \"$W_{so}$\",         \"$R_v$\",         \"$R_d$\",         \"$R_{so}$\",         \"$a_v$\",         \"$a_d$\",         \"$a_{so}$\",     ],     labelpad=0.2,     # bins=20,     bins=[         int(abs(max(all_chains[:, i]) - min(all_chains[:, i])) / ws[i])         for i in range(len(all_chains.T))     ],     label_kwargs={\"fontsize\": 40},     hist_kwargs={\"linewidth\": 3},     quantiles=None,     truths=alpha_central,     truth_color=\"r\",     smooth=(1.7),     smooth1d=1.0,     max_n_ticks=2 )   dim = len(all_chains[0]) ranges = [     [min(all_chains[:, i]), max(all_chains[:, i])] for i in range(len(all_chains.T)) ]  axes = np.array(figure.axes).reshape((dim, dim)) # print() for i in range(dim):     ax = axes[i, i]     ax.set_xlim(ranges[i][0], ranges[i][1])      for j in range(i):         ax = axes[i, j]         ax.set_ylim(ranges[i][0], ranges[i][1])         ax.set_xlim(ranges[j][0], ranges[j][1])   width = 24 height = 18 figure.set_size_inches(width, height) <p>Very interesting! In red we can see the original parametrization by Koning-Delaroche that we used as the center of our prior, the blue lines are the actual prior, and the black ones the posterior. Most parameters are more or less around that value, while some shifted appreciably.Some parameters are very well constrained by the data, while others seem to just be constrained by the prior.</p> <p>Thanks to ROSE, we now can make these kinds of analysis VERY fast!</p> In\u00a0[92]: Copied! <pre>labels = [\n    \"$V_v$\",\n    \"$W_v$\",\n    \"$W_d$\",\n    \"$V_{so}$\",\n    \"$W_{so}$\",\n    \"$R_v$\",\n    \"$R_d$\",\n    \"$R_{so}$\",\n    \"$a_v$\",\n    \"$a_d$\",\n    \"$a_{so}$\",\n]\n</pre> labels = [     \"$V_v$\",     \"$W_v$\",     \"$W_d$\",     \"$V_{so}$\",     \"$W_{so}$\",     \"$R_v$\",     \"$R_d$\",     \"$R_{so}$\",     \"$a_v$\",     \"$a_d$\",     \"$a_{so}$\", ] <p>Below we plot the parameters that all the chains, concatenated together, explored. The horizontal red lines are the KD values</p> In\u00a0[93]: Copied! <pre>XAll = np.arange(len(anglesX))\n\nplt.rc(\"xtick\", labelsize=15)\nplt.rc(\"ytick\", labelsize=15)\nfig, axs = plt.subplots(nparams, 1, figsize=(12, 12), sharex=\"all\")\n\nfor i in range(nparams):\n    axs[i].axhline(y=alpha_central[i], color=\"r\")\n    axs[i].plot(sep_chains[:, :, i].T, alpha=0.65)\n    axs[i].set_ylabel(labels[i], fontsize=18)\n\nplt.xlabel(\"MCMC samples\")\nplt.show()\n</pre> XAll = np.arange(len(anglesX))  plt.rc(\"xtick\", labelsize=15) plt.rc(\"ytick\", labelsize=15) fig, axs = plt.subplots(nparams, 1, figsize=(12, 12), sharex=\"all\")  for i in range(nparams):     axs[i].axhline(y=alpha_central[i], color=\"r\")     axs[i].plot(sep_chains[:, :, i].T, alpha=0.65)     axs[i].set_ylabel(labels[i], fontsize=18)  plt.xlabel(\"MCMC samples\") plt.show() In\u00a0[94]: Copied! <pre>XAll = np.arange(len(anglesX))\n</pre> XAll = np.arange(len(anglesX)) In\u00a0[95]: Copied! <pre>rng = np.random.default_rng()\ntheta_rand = rng.choice(all_chains, (1000), replace=False)\n</pre> rng = np.random.default_rng() theta_rand = rng.choice(all_chains, (1000), replace=False) In\u00a0[96]: Copied! <pre>rndm_m = np.array(\n    [rose_emulator.emulate_dsdo(theta_rand[i]) for i in range(len(theta_rand))]\n)\n</pre> rndm_m = np.array(     [rose_emulator.emulate_dsdo(theta_rand[i]) for i in range(len(theta_rand))] ) In\u00a0[97]: Copied! <pre># rndm_m = rbm(XAll, theta_rand).mean().T\n</pre> # rndm_m = rbm(XAll, theta_rand).mean().T In\u00a0[98]: Copied! <pre>KD_cs = rose_emulator.emulate_dsdo(alpha_central)\n</pre> KD_cs = rose_emulator.emulate_dsdo(alpha_central) In\u00a0[99]: Copied! <pre>fig, axs = plt.subplots(1, 1, figsize=(6, 4),dpi=600)\nmedian = np.percentile(rndm_m, 50, axis=0)\nupper = np.abs(np.percentile(rndm_m, 97.5, axis=0))\nlower = np.abs(np.percentile(rndm_m, 2.5, axis=0))\n\naxs.plot(angles, median, color=\"C0\", label=\"Median Prediction\")\naxs.fill_between(\n    angles,\n    lower,\n    upper,\n    color=\"C0\",\n    alpha=0.5,\n    label=r\"95$^{\\rm{th}}$ predictive interval\",\n)\n\naxs.scatter(anglesX * np.pi / 180, y, s=10, c=\"r\", alpha=0.5, label=\"Mcdonald, 1964\")\naxs.errorbar(anglesX * np.pi / 180, y, yerr=2 * yerr, fmt=\"o\", alpha=0.5, c=\"r\")\n\naxs.set_yscale(\"log\")\n\naxs.set_xlabel(r\"$\\theta$ [radians]\", fontsize=12)\naxs.set_ylabel(r\"$d\\sigma/d\\Omega$ [mb/sr] \", fontsize=12)\n\naxs.plot(angles, KD_cs, c=\"k\", linestyle=\"dashed\", label=\"Original KD\")\n\naxs.xaxis.set_major_locator(plt.MultipleLocator(np.pi / 6))\naxs.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=6)))\n\nplt.text(0.7, 5e2, r\"$^{40}\\rm{Ca}(n,n)$\", fontsize=14)\nplt.legend(fontsize=12)\n\nplt.tight_layout()\n</pre> fig, axs = plt.subplots(1, 1, figsize=(6, 4),dpi=600) median = np.percentile(rndm_m, 50, axis=0) upper = np.abs(np.percentile(rndm_m, 97.5, axis=0)) lower = np.abs(np.percentile(rndm_m, 2.5, axis=0))  axs.plot(angles, median, color=\"C0\", label=\"Median Prediction\") axs.fill_between(     angles,     lower,     upper,     color=\"C0\",     alpha=0.5,     label=r\"95$^{\\rm{th}}$ predictive interval\", )  axs.scatter(anglesX * np.pi / 180, y, s=10, c=\"r\", alpha=0.5, label=\"Mcdonald, 1964\") axs.errorbar(anglesX * np.pi / 180, y, yerr=2 * yerr, fmt=\"o\", alpha=0.5, c=\"r\")  axs.set_yscale(\"log\")  axs.set_xlabel(r\"$\\theta$ [radians]\", fontsize=12) axs.set_ylabel(r\"$d\\sigma/d\\Omega$ [mb/sr] \", fontsize=12)  axs.plot(angles, KD_cs, c=\"k\", linestyle=\"dashed\", label=\"Original KD\")  axs.xaxis.set_major_locator(plt.MultipleLocator(np.pi / 6)) axs.xaxis.set_major_formatter(plt.FuncFormatter(multiple_formatter(denominator=6)))  plt.text(0.7, 5e2, r\"$^{40}\\rm{Ca}(n,n)$\", fontsize=14) plt.legend(fontsize=12)  plt.tight_layout() <p>And we are done! This is truly a Bayesian calibration of our Optical potential and, as we can see, it really learned something from the data. Compare the black dashed line, the original KD global parametrization, with the median and 95% confidence intervals of our calibrated model.</p> <p>Now the power is yours, go ahead on many adventures and calibrate many reaction models with all the available data.</p> <pre><code>                                                                                                                                The ROSE team</code></pre>"},{"location":"tutorials/ROSE_tutorial_2_optical_potential_surmise_UQ/#uq-for-an-optical-potential","title":"UQ for an Optical Potential!\u00b6","text":"<p>One of the main motivations for building an emulator is to rapidly evaluate posteriors for Bayesian optimization and uncertainty-quantification. Often, our models have high dimensional parameter spaces, and are expensive to solve, making these analyzis computationally prohibitive. In this tutorial, we will use an emulator from <code>rose</code>, combined with the Bayesian optimization package <code>surmise</code>, which uses Markov-chain Monte Carlo (MCMC) to find the best fit values on the parameters space.</p>"},{"location":"tutorials/ROSE_tutorial_2_optical_potential_surmise_UQ/#experimental-data-for-neutron-scattering-on-40-ca","title":"Experimental data for neutron scattering on $^{40}$ Ca\u00b6","text":"<p>Let's consider the practical example of fitting an optical potential to a differential elastic scattering cross section measurement. In particular, we will use this measurement90087-2) from 1964 by McDonald and Robson, available here on Exfor.</p> <p>This was a measurement of 14 MeV neutrons incident on a $^{40}$ Ca target. The outgoing neutrons - also at 14 MeV, remember, this is an elastic reaction - were then measured in one of an array of detectors, each set up a different scattering angle relative to the incident beam. From the density of the target and the incident flux of the beam, the authors reconstructed $\\frac{d\\sigma}{d\\theta}$, the scattering cross section differentiated on the scattering angle (in the center-of-mass frame). Let's first take a look at this data, and then we'll talk about how to find the best-fit parameters and their uncertainties.</p>"},{"location":"tutorials/ROSE_tutorial_2_optical_potential_surmise_UQ/#specifying-the-prior","title":"Specifying the Prior\u00b6","text":""},{"location":"tutorials/ROSE_tutorial_2_optical_potential_surmise_UQ/#going-bayesian-with-surmise","title":"Going Bayesian with Surmise\u00b6","text":""},{"location":"tutorials/ROSE_tutorial_2_optical_potential_surmise_UQ/#wow-we-just-calibrated-an-optical-potential-in-3-minutes-with-uq","title":"Wow, we just calibrated an optical potential in 3 minutes, with UQ!\u00b6","text":"<p>According to the CAT plot at the beginning this would have taken at least 100 times longer with the high-fidelity. Now let's plot the results of the calibration.</p>"},{"location":"tutorials/ROSE_tutorial_2_optical_potential_surmise_UQ/#plotting-our-final-calibrated-model-alongside-the-data","title":"Plotting our final calibrated model alongside the data\u00b6","text":""}]}